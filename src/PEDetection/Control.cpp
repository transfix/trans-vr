/*
  Copyright 2006 The University of Texas at Austin

        Authors: Sangmin Park <smpark@ices.utexas.edu>
        Advisor: Chandrajit Bajaj <bajaj@cs.utexas.edu>

  This file is part of PEDetection.

  PEDetection is free software; you can redistribute it and/or
  modify it under the terms of the GNU Lesser General Public
  License version 2.1 as published by the Free Software Foundation.

  PEDetection is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public
  License along with this library; if not, write to the Free Software
  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
*/

#include <stdio.h>
#include <string.h>
#include <sys/time.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdlib.h>
#include <math.h>
#include <float.h>
//#include <stream.h>
#include <fstream.h>
//#include <iostream>
//#include <fstream>

#include <PEDetection/CompileOptions.h>
#include <PEDetection/Initialization.h>
#include <PEDetection/EM.h>
#include <PEDetection/Timer.h>
#include <PEDetection/Control.h>
#include <PEDetection/Evaluation.h>
#include <PEDetection/Thinning.h>
#include <PEDetection/Skeleton.h>
#include <PEDetection/Skeleton_SeedPts.h>
#include <PEDetection/MC_Geom.h>
//#include "VesselSeg2D.h"
#include <PEDetection/VesselSeg.h>
#include <PEDetection/MembraneSeg.h>
#include <PEDetection/Octree.h>


extern unsigned char		*datauc;
extern unsigned short		*dataus;
extern unsigned int			*dataui;

extern char					*datac;
extern short				*datas;
extern int					*datai;
extern float				*dataf;
extern double				*datad;

extern int				inWidth_gi, inHeight_gi, inDepth_gi, NumLeaping_gi;
//extern char				*InputFileName_gc, *TargetName_gc;
extern char TargetName_gc[512], InputFileName_gc[512];
extern float			MinValuef_gf;
extern char				*TypeName;	// uchar, ushort, char, short, float
extern unsigned char	*RawivHeader_guc;

extern double	P_WeightingFuzzy_gd;	// A weighting exponent on each fuzzy membership
extern double	Alpha_Neighbor_gd;		// The effect of the neighbors term
extern double	Epsilon_Termination_gd; // Condition of termination
extern double	NR_Cardinality_gd;		// The Cardinality of N_k = WindowSize*WindowSize
extern unsigned char TypeNumberForRawV;
extern int 		NumDataDiffusion_gi;

// .rawiv file header
extern float	MinCoor_gf[3];	// The coordinates of the 1st voxel.
extern float	MaxCoor_gf[3];	// The coordinates of the last voxel.
extern int		NumVerts_gi;	// The number of vertices in the grid = DimX * DimY * DimZ
extern int		NumCells_gi;	// The number of Cells in the grid = (DimX-1) * (DimY-1) * (DimZ-1)
extern int		DimX_gi, DimY_gi, DimZ_gi;	// The number of vertices in each direction
extern float 	OriginX_gf, OriginY_gf, OriginZ_gf;	// = the coordinates of the 1st voxel
extern float	SpanX_gf, SpanY_gf, SpanZ_gf;	// SpanX = (MaxCoor_gf[0]-MinCoor_gf[0])/(DimX-1)

extern double	MinOrg_gd, MaxOrg_gd;


cVesselSeg<unsigned char>	VesselSeg_g;



enum eFileType	{ RAWIV, RAW, PPM, PGM };
eFileType	FileType_g;

// Each type function should be generated by compiler
// in this module, before it is called
void FunctionGenerator()
{

  	Classification(datauc, 0, 0);
//	Classification(dataus, 0, 0);
//	Classification(dataf, 0, 0);

	SaveVolume(datauc, 0.0, 0.0, NULL);
	SaveVolume(dataus, 0.0, 0.0, NULL);
	SaveVolume(datai,  0.0, 0.0, NULL);
	SaveVolume(dataf,  0.0, 0.0, NULL);

	double	Min=0.0, Max=0.0;
	Bilateral_Filter((unsigned char *)NULL,	0, Min, Max, 0.0, 0.0);
	Bilateral_Filter((unsigned short *)NULL,0, Min, Max, 0.0, 0.0);
	Bilateral_Filter((float *)NULL, 		0, Min, Max, 0.0, 0.0);

	GaussianSmoothing3D(datauc, 3);
	GaussianSmoothing3D(dataus, 3);
	GaussianSmoothing3D(dataf, 3);

	Anisotropic_Diffusion_3DScalar(datauc, 0);
	Anisotropic_Diffusion_3DScalar(dataus, 0);
	Anisotropic_Diffusion_3DScalar(dataf, 0);

	SaveVolumeRawivFormat(datauc, 0.0, 0.0, NULL, 0, 0, 0, 0.0, 0.0, 0.0);
	SaveVolumeRawivFormat(dataus, 0.0, 0.0, NULL, 0, 0, 0, 0.0, 0.0, 0.0);
	SaveVolumeRawivFormat(datai, 0.0, 0.0, NULL, 0, 0, 0, 0.0, 0.0, 0.0);
	SaveVolumeRawivFormat(dataf, 0.0, 0.0, NULL, 0, 0, 0, 0.0, 0.0, 0.0);

}


template<class T>
void Classification(T *data_org, int NumMaterials, int WindowSize)
{
	int     	i, WHD;
	float 		*Material_Prob;
	float		Minf, Maxf;


	if (NumMaterials==0 && WindowSize==0) return;

	WHD = inWidth_gi*inHeight_gi*inDepth_gi;


//================================================================================
	Timer	Timer_Total;
	Timer_Total.Start();
//================================================================================


	T *data = data_org;
	data[0] = 0;	// for the Index() function


#ifdef	OCTREE
	cOctree<T>		Octree;
	
	printf ("Octree Generation ... ");
	printf ("\n"); fflush (stdout);
	
	Octree.setData(data);
	Octree.setWHD(inWidth_gi, inHeight_gi, inDepth_gi);
	Octree.ComputeOctree();
	
	Octree.setOutputFileName(TargetName_gc);
	Octree.PrintOctree();
	
	exit(1);	
#endif


#ifdef	BILATERAL_FILTER_FOR_DATA
	Timer	Timer_Bilateral_Data;
	Timer_Bilateral_Data.Start();
	//------------------------------------------------------------------------------
	// Applying a Bilateral Filter to the Gradients
	
	double	Filtered_Data_Mind=FLT_MAX, Filtered_Data_Maxd=FLT_MIN;
	double	Sigma_Domain_data = 50.0, Sigman_Range_data = 400.0;

	cout << "Apply Bilateral Filter to Data Values" << endl;
	T *data_Filtered = Bilateral_Filter (data_org, 5, Filtered_Data_Mind, Filtered_Data_Maxd, 
												Sigma_Domain_data, Sigman_Range_data);
	data = data_Filtered;

	cout << "Filtered Gradient Magnitude Min = " << Filtered_Data_Mind << " ";
	cout << "Max = " << Filtered_Data_Maxd << endl;
	//------------------------------------------------------------------------------
	Timer_Bilateral_Data.End("Timer: Applying a Bilateral Filter to Data Values");
#endif

#ifdef	ANISOTROPIC_DIFFUSION_FOR_DATA

	Timer	Timer_AnisotropicDiff_Data;
	Timer_AnisotropicDiff_Data.Start();
	//------------------------------------------------------------------------------
	// Applying an anisotropic diffusion filter to the data values
	char	DiffusionFileName[512];
	int		DiffusionData_fd1;
	int		NumDiffusion = NumDataDiffusion_gi;
	cout << "Apply Anisotropic Diffusion for the Input Data" << endl;
	switch (FileType_g) {
		case RAWIV: 		
			sprintf (DiffusionFileName, "%s_DiffusionR%02d.%s", TargetName_gc, NumDiffusion, "rawiv"); break;
		case RAW:
			sprintf (DiffusionFileName, "%s_DiffusionR%02d.%s", TargetName_gc, NumDiffusion, "raw"); break;
		case PPM:
			sprintf (DiffusionFileName, "%s_DiffusionR%02d.%s", TargetName_gc, NumDiffusion, "ppm"); break;
		case PGM:
			sprintf (DiffusionFileName, "%s_DiffusionR%02d.%s", TargetName_gc, NumDiffusion, "pgm"); break;
		default : cout << "Incorrect File Type = " << FileType_g << endl; break;
	}

	if ((DiffusionData_fd1 = open (DiffusionFileName, O_RDONLY)) < 0) {
		cout << DiffusionFileName << " does not exist" << endl;
		cout << "Create a New One: " <<  DiffusionFileName << endl;
		Anisotropic_Diffusion_3DScalar(data, NumDiffusion);
		
#ifdef	SAVE_VOLUME_Data_Diffusion		
		int		DiffusionData_fd2;
		if ((DiffusionData_fd2 = open (DiffusionFileName, O_CREAT | O_WRONLY)) < 0) {
			cout << "could not open " << DiffusionFileName << endl; exit(1);
		}
		if (FileType_g==RAWIV) {
			if (write(DiffusionData_fd2, RawivHeader_guc, 68)!=68) {
				cout << "The Diffusion file could not be written " << DiffusionFileName << endl;
				close (DiffusionData_fd2); exit(1);
			}
		}
		if (write(DiffusionData_fd2, data, sizeof(T)*WHD)!=(unsigned int)sizeof(T)*WHD) {
			cout << "The Diffusion file could not be written " << DiffusionFileName << endl;
			close (DiffusionData_fd2); exit(1);
		}
		if (chmod(DiffusionFileName, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH) < 0) {
			cout << "chmod was not worked to file " << DiffusionFileName << endl; exit(1); 
		}
#endif

	}
	else {
		cout << "The file exists: " <<  DiffusionFileName << endl;
		if (FileType_g==RAWIV) {
			unsigned char	TempHeader[68];
			if (read(DiffusionData_fd1, TempHeader, 68) != 68) {
				cout << "The file could not be read " << DiffusionFileName << endl;
				close (DiffusionData_fd1);
				exit(1);
			}
		}		
		if (read(DiffusionData_fd1, data, sizeof(T)*WHD) != (unsigned int)sizeof(T)*WHD) {
			cout << "The file could not be read " << DiffusionFileName << endl;
			close (DiffusionData_fd1);
			exit(1);
		}
	}

	
	//------------------------------------------------------------------------------
	Timer_AnisotropicDiff_Data.End("Timer: Applying a anisotropic diffusion filter for the data values");
	
#endif

	Minf = FLT_MAX;
	Maxf = -FLT_MAX;
	for (i=0; i<WHD; i++) {
		if (Maxf < (double)data[i]) Maxf = (double)data[i];
		if (Minf > (double)data[i]) Minf = (double)data[i];
	}

	//------------------------------------------------------------------------------
	// Save the Input Data Slices
#ifdef	SAVE_ORIGINAL_IMAGE
	SaveOrigSlices(data, Minf, Maxf, WindowSize, NumMaterials);
#endif
	//------------------------------------------------------------------------------

	double	GradientMind = 0.0, GradientMaxd = 1.0;
	float *Gradient_Vectorsf = NULL;
	float *Gradientf = NULL;

#ifdef	COMPUTE_GRADIENT_VEC_MAG
	Timer	Timer_Gradient;
	Timer_Gradient.Start();
	//------------------------------------------------------------------------------
	// Calculate Gradient Magnitude for Initialization
	
	cout << "Computing Gradient Vectors ... " << endl;

	 // Vectors are not normalized in the function

	#ifdef	GRADIENT_VECTOR_DIFFUSION_3D
		Timer	Timer_VDiff;
		Timer_VDiff.Start();
		//----------------------------------------------------
		char	DiffusionVecFileName[512];
		int		DiffusionVecData_fd1, DiffusionVecData_fd2;
		int		NumVecDiffusion = 2;
		
		cout << "Apply Anisotropic Diffusion for the Gradient Vectors" << endl;
		
		sprintf (DiffusionVecFileName, "%s_DiffusionVecR%02d.gvec", TargetName_gc, NumVecDiffusion);

		if ((DiffusionVecData_fd1 = open (DiffusionVecFileName, O_RDONLY)) < 0) {
			cout << DiffusionVecFileName << " does not exist" << endl;
			cout << "Create a New One: " <<  DiffusionVecFileName << endl;
			
			Gradient_Vectorsf = Calculate_Gradient_Vectors(data);
			Anisotropic_Vector_Diffusion_3D(Gradient_Vectorsf, NumVecDiffusion);
			
#ifdef		SAVE_VOLUME_Gvec_Diffusion
			if ((DiffusionVecData_fd2 = open (DiffusionVecFileName, O_CREAT | O_WRONLY)) < 0) {
				cout << "could not open " << DiffusionVecFileName << endl; exit(1);
			}
			if (write(DiffusionVecData_fd2, Gradient_Vectorsf, sizeof(float)*WHD*3)!=(unsigned int)sizeof(float)*WHD*3) {
				cout << "The diffusion vec file could not be written " << DiffusionVecFileName << endl;
				close (DiffusionVecData_fd2); exit(1);
			}
			if (chmod(DiffusionVecFileName, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH) < 0) {
				cout << "chmod was not worked to file " << DiffusionVecFileName << endl; exit(1); 
			}
#endif
		}
		else {
			Gradient_Vectorsf = new float [WHD*3];
			cout << "Read the file: " << DiffusionVecFileName << endl;
			if (read(DiffusionVecData_fd1, Gradient_Vectorsf, sizeof(float)*WHD*3)!=(unsigned int)sizeof(float)*WHD*3) {
				cout << "The file could not be read " << DiffusionVecFileName << endl;
				close (DiffusionVecData_fd1); exit(1);
			}
		}
		//----------------------------------------------------
		Timer_VDiff.End("Timer: Compute Gradient Vectors and Aniostropic Vector Diffusion");
	#else
		Timer	Timer_VDiff;
		Timer_VDiff.Start();
		//----------------------------------------------------
		Gradient_Vectorsf = Calculate_Gradient_Vectors(data);
		//----------------------------------------------------
		Timer_VDiff.End("Timer: Compute Gradient Vectors");
	#endif


	#ifdef	COMPUTE_GRADIENT_MAG
		Gradientf = Calculate_Gradient_Magnitude_From_Vectors(Gradient_Vectorsf, GradientMind, GradientMaxd);
		cout << "Min and Max of Gradient Magnitudes = " << GradientMind << ", " << GradientMaxd << endl;
	#else
		Gradientf = NULL;
		cout << "Gradient Magnitudes have not been computed" << endl;
	#endif

	
	//------------------------------------------------------------------------------
	Timer_Gradient.End("Timer: Calculating Gradient Vectors");
#endif


	float	*Filtered_Gradientf;
	
	if (Gradientf==NULL) Filtered_Gradientf = NULL;
	else Filtered_Gradientf = new float [WHD];
	double	Filtered_Mind=GradientMind, Filtered_Maxd=GradientMaxd;

#ifdef	COMPUTE_GRADIENT_VEC_MAG
	if (Filtered_Gradientf!=NULL) {
		for (i=0; i<WHD; i++) Filtered_Gradientf[i] = Gradientf[i];
	}
#else
	if (Filtered_Gradientf!=NULL) {
		for (i=0; i<WHD; i++) Filtered_Gradientf[i] = 0.0;
	}
#endif

	
#ifdef	COMPUTE_GRADIENT_VEC_MAG
#ifdef	BILATERAL_FILTER_FOR_GRADIENT
	Timer	Timer_Bilateral;
	Timer_Bilateral.Start();
	//------------------------------------------------------------------------------
	// Applying Bilateral Filter to the Gradients
	
	double	Filtered_Mind=FLT_MAX, Filtered_Maxd=FLT_MIN;
	double	Sigma_Domain = 50.0, Sigman_Range = 400.0;
	char	BilateralFileName[500];
	int		Bilateral_fd1, Bilateral_fd2;


	cout << "Apply Bilateral Filter to Gradients" << endl;
	sprintf (BilateralFileName, "%s_FilteredGradientM.bilateral", TargetName_gc);
	if ((Bilateral_fd1 = open (BilateralFileName, O_RDONLY)) < 0) {
		cout << "Could Not Open the File, " <<  BilateralFileName << endl;
		cout << "Create a New One: " <<  BilateralFileName << endl;
		Filtered_Gradientf = Bilateral_Filter(Gradientf, 5, Filtered_Mind, Filtered_Maxd, Sigma_Domain, Sigman_Range);



		//------------------------------------------------------------------------------------------------
		// Trim Top 5% Gradient Magnitue Values
		//------------------------------------------------------------------------------------------------
		cout << "Calculate Histrogram of Gradient Magnitude" << endl;
		cout << "Min & Max Grad M = " << Filtered_Mind << ", " << Filtered_Maxd << endl;
		float	HistogramFactorGradM; // for float tyep data
		HistogramFactorGradM = (float)10000/(Filtered_Maxd-Filtered_Mind);
	
		// Histogram for the EM algorithm to make the algorithm efficient
		int		*HistogramGradM = new int[(int)((Filtered_Maxd-Filtered_Mind)*HistogramFactorGradM)+1];
		for (i=0; i<(int)((Filtered_Maxd-Filtered_Mind)*HistogramFactorGradM)+1; i++) HistogramGradM[i]=0;
		for (i=0; i<WHD; i++) {
			HistogramGradM[(int)((Filtered_Gradientf[i]-Filtered_Mind)*HistogramFactorGradM)]++;
		}

		int		AccFreq = 0;
		for (i=9999; i>0; i--) {
			AccFreq += HistogramGradM[i];
			if ((double)AccFreq>(double)WHD*0.001) {
				Filtered_Maxd = (double)i/HistogramFactorGradM + Filtered_Mind;
				break;
			}
		}
		delete [] HistogramGradM;
		for (i=0; i<WHD; i++) {
			if (Filtered_Gradientf[i] > Filtered_Maxd) Filtered_Gradientf[i] = (float)Filtered_Maxd;
		}
		cout << "# Changed Voxels (Grad. Mag.) = " << AccFreq << endl;
		cout << "Modified Min & Max Grad M = " << Filtered_Mind << ", " << Filtered_Maxd << endl;
		cout.flush();
		//------------------------------------------------------------------------------------------------

		if ((Bilateral_fd2 = open (BilateralFileName, O_CREAT | O_WRONLY)) < 0) {
			cout << "could not open " << BilateralFileName << endl;
			exit(1);
		}
		if (write(Bilateral_fd2, Filtered_Gradientf, sizeof(float)*WHD)	!=sizeof(float)*WHD) {
			cout << "The bilateral file could not be written " << BilateralFileName << endl;
			close (Bilateral_fd2);
			exit(1);
		}
		if (chmod(BilateralFileName, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH) < 0) {
			cout << "chmod was not worked to file " << BilateralFileName << endl;
			exit(1);
		}
	}
	else {
		cout << "Read the file, which has bilateral-filtered magnitudes values. " <<  BilateralFileName << endl;
		if (read(Bilateral_fd1, Filtered_Gradientf, sizeof(float)*WHD) != sizeof(float)*WHD) {
			cout << "The file could not be read " << BilateralFileName << endl;
			close (Bilateral_fd1);
			exit(1);
		}
		for (i=0; i<WHD; i++) {
			if (Filtered_Maxd < (float)Filtered_Gradientf[i]) Filtered_Maxd = (float)Filtered_Gradientf[i];
			if (Filtered_Mind > (float)Filtered_Gradientf[i]) Filtered_Mind = (float)Filtered_Gradientf[i];
		}
	}
	
	cout << "Filtered Gradient Magnitude Min = " << Filtered_Mind << " ";
	cout << "Max = " << Filtered_Maxd << endl;
//	float	*Filtered_Gradientf = Mean_Filter(Gradientf, 5, Filtered_Mind, Filtered_Maxd);
	//------------------------------------------------------------------------------
	Timer_Bilateral.End("Timer: Applying the Bilateral Filter to the Gradients");
#endif
#endif

#ifdef	COMPUTE_GRADIENT_VEC_MAG
#ifdef	SAVE_GRADIENT_IMAGE
	if (Filtered_Gradientf!=NULL) {
		SaveGradient(Gradientf, Filtered_Gradientf, GradientMind, GradientMaxd, WindowSize, NumMaterials);
	}
#endif
#endif
	delete [] Gradientf;
	Gradientf = NULL;
	cout << "Gradientf is deleted" << endl; cout.flush();



#ifdef	MARCHING_CUBES_INTENSITY
	//------------------------------------------------------------------------------
	// Extracting iso-Surfaces
	cMarchingCubes<T>		MC;
	double					ZeroSurface_d;
	
	
//	ZeroSurface_d = 16.2991;		// membraine0128
//	ZeroSurface_d = 15.7197330;		// membraine0256
//	ZeroSurface_d = 24.057769;		// membraine0513
//	ZeroSurface_d = 16.114350;		// membraine1024
//	ZeroSurface_d = 35.046374;		// membraine_1.rawiv
	ZeroSurface_d = 105.9394572;	// membrane_1_Sub63-1024.rawiv and membrane_1_Sub63-512.rawiv
	#ifdef	MEMBRANE_SEGMENTATION

		cMembraneSeg<T>		Mem;

		Mem.setData(data, Minf, Maxf);
		Mem.setWHD(inWidth_gi, inHeight_gi, inDepth_gi); // Setting W H D
		Mem.setZeroSurface(ZeroSurface_d);	 // membraine0256
		Mem.setFileName(TargetName_gc);	 // Output File Name
		
		T	*NewData = NULL;
		

//		NewData = Mem.TopSurfaceSeg();
//		NewData = Mem.DownSurfaceSeg();
//		NewData = Mem.Class(2);	// Nerve Cell Membrane
//		NewData = Mem.Class(4);	// Vertical Muscle Cell Membrane
//		NewData = Mem.Class(6);	// Horizontal Muscle Cell Membrane


//		MC.setData(NewData, Minf, Maxf);
		MC.setData(data, Minf, Maxf);
	#else
		MC.setData(data, Minf, Maxf);
	#endif
	/*
	float	SpanX_f, SpanY_f, SpanZ_f, MaxSpan_f;
	SpanX_f = SpanX_gf;
	SpanY_f = SpanY_gf;
	SpanZ_f = SpanZ_gf;
	MaxSpan_f = SpanX_f;
	if (MaxSpan_f < SpanY_f) MaxSpan_f = SpanY_f;
	if (MaxSpan_f < SpanZ_f) MaxSpan_f = SpanZ_f;
	SpanX_f /= MaxSpan_f;
	SpanY_f /= MaxSpan_f;
	SpanZ_f /= MaxSpan_f;
	MC.setSpanXYZ(SpanX_f, SpanY_f, SpanZ_f);
	*/
	
	MC.setWHD(inWidth_gi, inHeight_gi, inDepth_gi); // Setting W H D
	MC.setGradientVectors(Gradient_Vectorsf);

	cout << "Control: Start to extract geometries from intensity values" << endl;
	// Iso-value should be between 0 and 255
//	MC.ExtractingIsosurfaces(133.0);	// CV (D1-SRS01) & test datasets
	MC.ExtractingIsosurfaces(ZeroSurface_d);
	
//	MC.SaveGeometry_VRML(TargetName_gc, VRML_LINE);
//	MC.SaveGeometry_VRML(TargetName_gc, VRML_FACE);

	MC.ComputeSurfaceArea();
	
	MC.SaveGeometry_RAW(TargetName_gc);

	MC.Destroy();
	exit(1);
	
	#ifdef	MEMBRANE_SEGMENTATION
		delete [] NewData; NewData = NULL;
		exit(1);
	#endif
	//------------------------------------------------------------------------------
#endif







	Timer	Timer_Histogram;
	Timer_Histogram.Start();
	//-----------------------------------------------------------------------
	// Histogram
	cout << "Calculate Histrogram " << endl;
	float	HistogramFactor; // for float tyep data
	cout << "The size of the data type = " << sizeof(data[0]) << endl;
	if (sizeof(data[0])==4) { // Considering float type datasets
#ifdef 	MAXNUM_HISTOGRAM_ELEMENTS
//		if ((Maxf-Minf)<MAXNUM_HISTOGRAM_ELEMENTS) {
			HistogramFactor = (float)MAXNUM_HISTOGRAM_ELEMENTS/(Maxf-Minf);
//		}
#endif
	}
	else HistogramFactor = 1.0;
	cout << "Histogram Factor = " << HistogramFactor << endl;
	cout << "Num elements in the Histogram = " << (int)((Maxf-Minf)*HistogramFactor) << endl;
	
	// Histogram for the EM algorithm to make the algorithm efficient
	int		*Histogram = new int[(int)((Maxf-Minf)*HistogramFactor)+1];
	for (i=0; i<(int)((Maxf-Minf)*HistogramFactor)+1; i++) Histogram[i]=0;
	for (i=0; i<WHD; i++) {
		Histogram[(int)((data[i]-Minf)*HistogramFactor)]++;
	}

	int		*HistogramOrg = new int[(int)(Maxf-Minf)+1];
	for (i=0; i<(int)(Maxf-Minf)+1; i++) HistogramOrg[i]=0;
	for (i=0; i<WHD; i++) {
		HistogramOrg[(int)(data[i]-Minf)]++;
	}
	//------------------------------------------------------------------------------
	Timer_Histogram.End("Timer: Calculate Histrogram");



#ifdef		AUTOMATIC_INITIALIZATION
	Timer	Timer_GVF;
	Timer_GVF.Start();
	//------------------------------------------------------------------------------
	// Calculate Gradient Vector Field
	cGVF<T>		gvf;
	char		InitialValueFileName[200];
	fstream		InitValue_File;
	filebuf 	*fb_InitValue_File;
	int			*SeedPtXYZ_i = NULL, NumSeedPts = 0;
	char		GVFlFileName[500];
	sprintf (GVFlFileName, "%s_GradientVectors.GVF", TargetName_gc);
	
	
	sprintf (InitialValueFileName, "%s.Init", TargetName_gc);
	InitValue_File.open (InitialValueFileName, ifstream::in);
	fb_InitValue_File = InitValue_File.rdbuf();
	if (fb_InitValue_File->is_open()) {
		// Don't need the GVF file
		cout << "The initial value file exists: " << InitialValueFileName << endl;
		gvf.setData(data, Minf, Maxf);
		gvf.setGradient(Filtered_Gradientf);
		gvf.setWHD(inWidth_gi, inHeight_gi, inDepth_gi);
//		gvf.setWHD(inWidth_gi, inHeight_gi, inDepth_gi, GVFlFileName);
	}
	else {

		gvf.setData(data, Minf, Maxf);
		gvf.setGradient(Filtered_Gradientf); // Setting the Gradient Magnitude Variable
		// Setting W H D and Computing the GVF with vector diffusion
		gvf.setWHD(inWidth_gi, inHeight_gi, inDepth_gi, GVFlFileName);

		cout << "Find Seed Points" << endl;
		NumSeedPts = gvf.FindSeedPts();

		cout << "Control.cpp: The Number of Found Seed Points = " << NumSeedPts << endl;
		SeedPtXYZ_i = gvf.getFoundSeedPtsLocations(); // map.clear() is included 
	}

	//------------------------------------------------------------------------------
	Timer_GVF.End("Timer: Compute GVF and Seed Points");



	Timer	Timer_Init;
	Timer_Init.Start();
	//------------------------------------------------------------------------------
	// Automatic Initialization
	// Find local minimums and the number of materials

	int			NumFoundInitialValues;
	int			*InitialValueLocations = NULL;
	T			*InitialValues = NULL;
	
	if (fb_InitValue_File->is_open()) {
		cout << "The initial value file exists, " << InitialValueFileName << endl;
		InitValue_File.close();
		SeedPtXYZ_i = ReadSeedPts(InitialValueFileName, NumSeedPts);

#ifdef	SAVE_SEED_PTS
//		T MinValueT = 87,		MaxValueT = 255; // CV (D1-SRS01)
//		T MinValueT = 73,		MaxValueT = 114; // LZ (D1-SRS02)
//		T MinValueT = 71,		MaxValueT = 104; // RK (D2-SRS01)
//		gvf.SaveSeedPtImages(SeedPtXYZ_i, NumSeedPts, MinValueT, MaxValueT);
#endif

	}
	else {
		cout << "Initial Value File does not exist, " << InitialValueFileName << endl;
		cout << "Initial Value File will be created, " << InitialValueFileName << endl << endl;
		cout << "Start to find initial values ... " << endl;
		cout << "inWHD = " << inWidth_gi << " " << inHeight_gi << " " << inDepth_gi << endl;
		cInitialValue<T>	Init;

		Init.setData(data, Minf, Maxf);	
		Init.setGradient(Filtered_Gradientf);
		Init.setHistogram(HistogramOrg);
		Init.setWHD(inWidth_gi, inHeight_gi, inDepth_gi);
		Init.setGVF(&gvf);
		
		// Before the function, DistanceHistogramMergeInitialValues(), it finds the maximum number of 
		// initial values for the EM algorithm.
		// Find Initial Values() uses gvf, so it should be alive during the function execution time
		int		IntermediateNumMaterials = Init.FindInitialValues(NumSeedPts, SeedPtXYZ_i); // Using GVF

		cout << "Intermediate Number of Materials = " << IntermediateNumMaterials << endl;
		
		cout << "Initial Value File is being created, " << InitialValueFileName << endl;
		
		//-------------------------------------------------------------------------------------
		// fstream version
		//-------------------------------------------------------------------------------------
		/*
		InitValue_File.open (InitialValueFileName, ifstream::out);
		fb_InitValue_File = InitValue_File.rdbuf();
		if (!fb_InitValue_File->is_open()) {
			cout << "Could not open: " << InitialValueFileName << endl;
			exit(1);
		}

		int		NumInitialValues;
		InitialValues = new T [IntermediateNumMaterials];
		InitialValueLocations = new int [IntermediateNumMaterials*3];
		for (i=IntermediateNumMaterials; i>=2; i--) {

			NumInitialValues = Init.AgglomerativeMerging(i);
			if (NumInitialValues<i) continue;

			NumFoundInitialValues = Init.getNumInitialValues();
			printf ("Found Initial Values... = %d\n", NumFoundInitialValues); fflush (stdout);

			Init.getInitalValues(InitialValues);
			Init.getInitialValueLocations(InitialValueLocations);
			Init.DisplayInitialValuesRange(NumFoundInitialValues);
			printf ("Found Initial Values... = %d\n", NumFoundInitialValues); fflush (stdout);

			InitValue_File << NumFoundInitialValues << endl;
			for (i=0; i<NumFoundInitialValues; i++) {
				if (sizeof(InitialValues[i]==1)) // Considering unsigned char type
					InitValue_File << (int)InitialValues[i] << " ";
				else InitValue_File << InitialValues[i] << " ";
				InitValue_File << InitialValueLocations[i*3] << " ";
				InitValue_File << InitialValueLocations[i*3+1] << " ";
				InitValue_File << InitialValueLocations[i*3+2] << endl;
			}
		}
		*/
		

		//-------------------------------------------------------------------------------------
		// fopen version
		//-------------------------------------------------------------------------------------
		FILE	*InitValue_File_stream;
		
		InitValue_File_stream = fopen(InitialValueFileName, "w");
		if (InitValue_File_stream==NULL) {
			cout << "Could not open: " << InitialValueFileName << endl;
			exit(1);
		}

		int		NumInitialValues;
		InitialValues = new T [IntermediateNumMaterials];
		InitialValueLocations = new int [IntermediateNumMaterials*3];
		for (i=IntermediateNumMaterials; i>=2; i--) {

			NumInitialValues = Init.AgglomerativeMerging(i);
			if (NumInitialValues<i) continue;

			NumFoundInitialValues = Init.getNumInitialValues();
			printf ("Found Initial Values... = %d\n", NumFoundInitialValues); fflush (stdout);

			Init.getInitalValues(InitialValues);
			Init.getInitialValueLocations(InitialValueLocations);
			Init.DisplayInitialValuesRange(NumFoundInitialValues);
			printf ("Found Initial Values... = %d\n", NumFoundInitialValues); fflush (stdout);

			fprintf (InitValue_File_stream, "%d\n", NumFoundInitialValues);
			for (i=0; i<NumFoundInitialValues; i++) {
				if (sizeof(InitialValues[i]==1)) // Considering unsigned char type
					fprintf (InitValue_File_stream, "%d ", (int)InitialValues[i]);
				else fprintf (InitValue_File_stream, "%d ", (int)InitialValues[i]);

				fprintf (InitValue_File_stream, "%d ", (int)InitialValueLocations[i*3]);
				fprintf (InitValue_File_stream, "%d ", (int)InitialValueLocations[i*3+1]);
				fprintf (InitValue_File_stream, "%d\n", (int)InitialValueLocations[i*3+2]);
			}
		}


		//---------------------------------------------------------------
		// Remove unnecessary seed points and save correct seed points
		printf ("# NumSeedPts = %d\n", NumSeedPts); fflush (stdout);
		
		int		DataLoc;
		int		TempNumSeedPts = 0;
		int		*TempSeedPts_i = new int[NumSeedPts*3];
		for (i=0; i<NumSeedPts; i++) {
			DataLoc =	Index (SeedPtXYZ_i[i*3], SeedPtXYZ_i[i*3+1], SeedPtXYZ_i[i*3+2]);

			if ((float)data[DataLoc]>2.0) {
				TempSeedPts_i[TempNumSeedPts*3]   = SeedPtXYZ_i[i*3];
				TempSeedPts_i[TempNumSeedPts*3+1] = SeedPtXYZ_i[i*3+1];
				TempSeedPts_i[TempNumSeedPts*3+2] = SeedPtXYZ_i[i*3+2];
				TempNumSeedPts++;
			}
		}
		NumSeedPts = TempNumSeedPts;
		printf ("After removing unnecessary seed points: ");
		printf ("# Seed Pts = %d ", NumSeedPts);
		printf ("\n"); fflush (stdout);
		for (i=0; i<NumSeedPts*3; i++) SeedPtXYZ_i[i] = TempSeedPts_i[i];
		delete [] TempSeedPts_i;
		//---------------------------------------------------------------
		
		//-------------------------------------------------------------------------------------
		// fstream version
		//-------------------------------------------------------------------------------------
		/*
		// Save seed point locations
		InitValue_File << NumSeedPts << endl;
		for (i=0; i<NumSeedPts; i++) {
			InitValue_File << SeedPtXYZ_i[i*3] << " ";
			InitValue_File << SeedPtXYZ_i[i*3+1] << " ";
			InitValue_File << SeedPtXYZ_i[i*3+2] << endl;
		}
		InitValue_File.close();
		*/

		//-------------------------------------------------------------------------------------
		// fopen version
		//-------------------------------------------------------------------------------------
		// Save seed point locations
		fprintf (InitValue_File_stream, "%d\n", 3);
		for (i=0; i<3; i++) {
			fprintf (InitValue_File_stream, "%d ", SeedPtXYZ_i[i*3]);
			fprintf (InitValue_File_stream, "%d ", SeedPtXYZ_i[i*3+1]);
			fprintf (InitValue_File_stream, "%d\n", SeedPtXYZ_i[i*3+2]);
		}
		fclose (InitValue_File_stream);

		
		delete [] InitialValues;			InitialValues = NULL;
		delete [] InitialValueLocations;	InitialValueLocations = NULL;
		
	}
	
#ifdef	VESSELSEG
//	printf ("Control: Getting Gradient Mag Vectors\n"); fflush (stdout);
//	char	GVFlFileName[500];
//	sprintf (GVFlFileName, "%s_GradientVectors.GVF", TargetName_gc);
//	float	*GradientVectors_f = gvf.getGradientMVectors(GVFlFileName);
#endif

	gvf.Destroy();


//	SaveOrigSlicesWithInitialValues(data, Minf, Maxf, NumFoundInitialValues, InitialValueLocations);
	//------------------------------------------------------------
	Timer_Init.End("Timer: Automatic Initialization");
#endif // #ifdef		AUTOMATIC_INITIALIZATION
	

	// Evaluation
	cEvaluation<T>		Evaluation;
	Evaluation.setData(data, Minf, Maxf);	
	Evaluation.setWHD(inWidth_gi, inHeight_gi, inDepth_gi);
	Evaluation.setGradient(Filtered_Gradientf, (float)Filtered_Mind, (float)Filtered_Maxd);
	Evaluation.setHistogram(Histogram, HistogramFactor);

	// Transfer Function Generation & PE Detection
	cPEDetection<T>	PED;
	PED.setData(data, Minf, Maxf);
	PED.setWHD(inWidth_gi, inHeight_gi, inDepth_gi);
	PED.setGradient(Filtered_Gradientf, (float)Filtered_Mind, (float)Filtered_Maxd);
	PED.setGradientVectors(Gradient_Vectorsf);

#ifdef	COMPUTE_SECOND_DERIVATIVE
	Timer	Timer_ComputeSecondD;
	Timer_ComputeSecondD.Start();
	//------------------------------------------------------------------------------
	cout << "Compute the Second Derivatives " << endl;
	PED.ComputeSecondDerivative(TargetName_gc);
	
	#ifdef	SAVE_SECOND_DERIVATIVE
		PED.SaveSecondDerivative(TargetName_gc, NumLeaping_gi);
	#endif
	//------------------------------------------------------------
	Timer_ComputeSecondD.End("Timer: Compute the second derivative");
#else
	PED.DoNotComputeSecondDerivative(TargetName_gc);
#endif

	Evaluation.setSecondDerivative(PED.getSecondDerivative(), PED.getMinSecondD(), PED.getMaxSecondD());



	//------------------------------------------------------------
	// Expectation Maximization
	int		NumClusters, FoundInitValue_b;
	int		MaxNumInitialValues = FindAMaxInitialValue(InitialValueFileName);

	delete [] InitialValues;
	delete [] InitialValueLocations;
	InitialValues = new T[MaxNumInitialValues];
//	InitialValueLocations = new int[MaxNumInitialValues*3];

	cEMClustering<T> clusters((int)((Maxf-Minf)*HistogramFactor)+1, MaxNumInitialValues);
	clusters.setHistogram(Histogram, HistogramFactor);
	clusters.setData(data, Minf, Maxf);

	int		StartingNum, EndNum;

	if (MaxNumInitialValues>=12) StartingNum = 12;
	else StartingNum = MaxNumInitialValues;
	if (StartingNum==2) EndNum = 2;
	else EndNum = 3;

	cout << "Max Num. of Initial Values = " << MaxNumInitialValues << endl;
	cout << "Evaluation is between 12 and 3" << endl;
	
	for (NumClusters=StartingNum; NumClusters>=EndNum; NumClusters--) {

		cout << "The number of clusters = " << NumClusters << endl; cout.flush();
		
		// Read the initial value file --------------------------

		FoundInitValue_b = ReadInitialValues(InitialValueFileName, NumClusters, NumFoundInitialValues, InitialValues);

#ifdef DEBUG_CONTROL
		cout << "Found Init Value (Boolean) = " << FoundInitValue_b << endl; cout.flush();
		for (i=0; i<NumFoundInitialValues; i++) {
			if (sizeof(InitialValues[i])==1)
				cout << "Initial Values = " << (int)InitialValues[i] << ", ";
			else cout << "Initial Values = " << InitialValues[i] << ", ";
		}
		cout << endl;
#endif

		if (FoundInitValue_b) { }
		else continue;
		// The end of Reading -----------------------------------
	
		Timer	Timer_EM;
		Timer_EM.Start();
		//-------------------------------------------------------
		cout << "Control: Start EM ... " << endl;
		clusters.InitializeEM(NumClusters);
		for (i=0; i<NumFoundInitialValues; i++) {
			clusters.setMeanVariance(i, (double)InitialValues[i], (double)1200);
		}
		clusters.iterate();
		Material_Prob = clusters.getProbability();
		//-------------------------------------------------------
		Timer_EM.End("Timer: EM");

 
		
#ifdef	CLASSIFICATION_EVALUATION
		// 1. Find material ranges
		// 2. Evaluate the ranges
		// 3. Insert the evaluation records to a map
		cout << "Control: Compute Ave. of the second derivative at boundaries" << endl;
		Evaluation.FindAndEvaluateRanges(Material_Prob, NumFoundInitialValues);

		cout << endl << "Control: Display All Material Ranges" << endl;
		Evaluation.DisplayMatRangeInfoFormated();
#endif


		if (NumFoundInitialValues==NumMaterials) {
#ifdef		SAVE_CLASSIFICATION
			SaveClassificationWithHistogram(data, Material_Prob, Minf, Maxf, Histogram, HistogramFactor, 
												WindowSize, NumFoundInitialValues, "EM");
#endif
#ifdef		SAVE_RANGES_HISTOGRAM
			SaveRangesWithHistogram(data, Material_Prob, Minf, Maxf, Histogram, HistogramFactor, 
									WindowSize, NumFoundInitialValues, "EM");
#endif
#ifdef		SAVE_MATERIAL_VOLUME_RAWIV
			SaveMaterialVolumeWithHistogram(data, Material_Prob, Minf, Maxf, Histogram, HistogramFactor, 
												WindowSize, NumFoundInitialValues, "EM");
#endif
#ifdef		SAVE_MATERIAL_VOLUME_RAWV
			SaveMaterialVolumeRawVWithHistogram(data, Material_Prob, Minf, Maxf, Histogram, HistogramFactor, 
												WindowSize, NumFoundInitialValues, TargetName_gc);
#endif
#ifdef		SAVE_MEMBERSHIP_VALUES
			SaveMembershipValues(data, Material_Prob, Minf, Maxf, Histogram, HistogramFactor, NumFoundInitialValues);
#endif
		}

		//------------------------------------------------------------------------------

		// Transfer Function Generation & PE Detection
		PED.setProbabilityHistogram(Material_Prob, NumFoundInitialValues, Histogram, HistogramFactor);

#ifdef	PE_DETECTION
		

	#ifdef	VESSELSEG
	Timer	Timer_Vessel_Seg;
	Timer_Vessel_Seg.Start();
	//------------------------------------------------------------------------------
	// Distance based skeletonization
		//cVesselSeg2D<T>	VesselSeg;
		
		VesselSeg_g.setWHD(inWidth_gi, inHeight_gi, inDepth_gi);
		VesselSeg_g.setData(data, Minf, Maxf, true);
		VesselSeg_g.setProbabilityHistogram(Material_Prob, NumFoundInitialValues, Histogram, HistogramFactor);
		VesselSeg_g.setGradient(Filtered_Gradientf, (float)Filtered_Mind, (float)Filtered_Maxd);
		VesselSeg_g.setGradientVectors(Gradient_Vectorsf);
		VesselSeg_g.setSecondDerivative(PED.getSecondDerivative(), PED.getMinSecondD(), PED.getMaxSecondD());

//		VesselSeg_g.setSeedPts(NumSeedPts, SeedPtXYZ_i);
		printf ("Control: Span XYZ = (%f, %f, %f)\n", SpanX_gf, SpanY_gf, SpanZ_gf); fflush (stdout);
		VesselSeg_g.setXYZSpans(SpanX_gf, SpanY_gf, SpanZ_gf);
		
		cout << "Blood Vessel Extraction ... " << endl; cout.flush();

		
//		VesselSeg_g.SeedPtsBased_Skeletonization(233.10); // for general data
//		exit(1);
		

		int			j, ithCluster, loc[3];
		T	RangeMin[8], RangeMax[8];
		
		for (ithCluster=0; ithCluster<NumClusters; ithCluster++) {
			for (j=0; j<(int)((Maxf-Minf)*HistogramFactor); i++) {
				// Find RangeMin
				for (i=j; i<(int)((Maxf-Minf)*HistogramFactor); i++) {
					if (Histogram[i]>0) {
						loc[0]= i*NumClusters + ithCluster;
						if (Material_Prob[loc[0]]>=0.1) { RangeMin[ithCluster] = (T)i; break; }
					}
				}
				i++;
				// Find RangeMax
				for (; i<(int)((Maxf-Minf)*HistogramFactor); i++) {
					loc[0]= i*NumClusters + ithCluster;
					if (Material_Prob[loc[0]]<0.1) { RangeMax[ithCluster] = (T)(i-1); break; }
				}
				j=i+1;
			}
		}
		// Considering the final data value
		RangeMax[NumClusters-1] = (T)(int)((Maxf-Minf)*HistogramFactor);

		for (ithCluster=0; ithCluster<NumClusters; ithCluster++) {
			printf ("Ith Material = %d ", ithCluster);
			printf ("Min & Max = %3d %3d ", (int)RangeMin[ithCluster], (int)RangeMax[ithCluster]);
			printf ("\n"); fflush (stdout);
		}
		printf ("Two Lungs    : %3d %3d\n", (int)RangeMin[1], (int)RangeMax[2]);
		printf ("Soft Tissue  : %3d %3d\n", (int)RangeMin[3], (int)RangeMax[3]);
		printf ("Muscles      : %3d %3d\n", (int)RangeMin[4], (int)RangeMax[4]);
		printf ("Blood Vessels: %3d %3d\n", (int)RangeMin[5], (int)RangeMax[6]);
		printf ("\n"); fflush (stdout);

		VesselSeg_g.VesselExtraction(TargetName_gc, 
									RangeMin[1], RangeMax[2], 		// Two Lungs
									RangeMin[3], RangeMax[3], 		// Soft Tissue
									RangeMin[4], RangeMax[4], 		// Muscles
									RangeMin[5], RangeMax[6]);		// Blood Vessels



		// Intensity Ranges:
		// LungMatMin, LungMatMax, MuscleMatMin, MuscleMatMax, VesselMatMin, VesselMatMax
//		VesselSeg_g.VesselExtraction(TargetName_gc, (T)4, (T)51, (T)63, (T)70, (T)92, (T)126); // CV_high (D1-SRS01_high)
//		VesselSeg_g.VesselExtraction(TargetName_gc, (T)4, (T)17, (T)63, (T)69, (T)76, (T)133); // Patient_02_high
//		VesselSeg_g.VesselExtraction(TargetName_gc, (T)2, (T)48, (T)64, (T)71, (T)72, (T)135); // Patient_03_high

//		VesselSeg_g.VesselExtraction(TargetName_gc, (T)1, (T)14, (T)59, (T)68, (T)69, (T)132); // Patient_20_high O
//		VesselSeg_g.VesselExtraction(TargetName_gc, (T)1, (T)16, (T)61, (T)70, (T)71, (T)109); // Patient_33_high O
//		VesselSeg_g.VesselExtraction(TargetName_gc, (T)1, (T)18, (T)62, (T)72, (T)73, (T)131); // Patient_41_high X

//		VesselSeg_g.VesselExtraction(TargetName_gc, (T)3, (T)16, (T)65, (T)73, (T)74, (T)154); // Patient_05_high
//		VesselSeg_g.VesselExtraction(TargetName_gc, (T)2, (T)50, (T)62, (T)70, (T)62, (T)145); // LZ_high (D1-SRS02_high)
//		VesselSeg_g.VesselExtraction(TargetName_gc, (T)2, (T)19, (T)61, (T)68, (T)61, (T)118); // RK_high (D2-SRS01_high)
//		VesselSeg_g.VesselExtraction(TargetName_gc, (T)4, (T)46, (T)62, (T)68, (T)80, (T)157); // Patient_04_high



//		VesselSeg_g.VesselExtraction(TargetName_gc, (T)5, (T)54, (T)55, (T)62, (T)87, (T)255); // CV (D1-SRS01)
//		VesselSeg_g.VesselExtraction(TargetName_gc, (T)7, (T)48, (T)49, (T)71, (T)73, (T)114); // LZ (D1-SRS02)
//		VesselSeg_g.VesselExtraction(TargetName_gc, (T)5, (T)47, (T)56, (T)62, (T)72, (T)104); // RK (D2-SRS01)
//		SK_SeedPts.Skeletonize(TargetName_gc, (T)5, (T)28, (T)55, (T)66, (T)73, (T)255); // Patient 02
//		SK_SeedPts.ConnectedComponents(TargetName_gc, MinT, MaxT);

	//------------------------------------------------------------------------------
	Timer_Vessel_Seg.End("Timer: Vessel Segmentation");
	break;
	#endif


	#ifdef	SKELETON
	Timer	Timer_Skeleton;
	Timer_Skeleton.Start();
	//------------------------------------------------------------------------------
	// Distance based skeletonization
		cSkeleton<T>	SK;
		SK.setData(data, Minf, Maxf);
		SK.setWHD(inWidth_gi, inHeight_gi, inDepth_gi);
		SK.setProbabilityHistogram(Material_Prob, NumFoundInitialValues, Histogram, HistogramFactor);
		SK.setGradient(Filtered_Gradientf, (float)Filtered_Mind, (float)Filtered_Maxd);
		SK.setGradientVectors(Gradient_Vectorsf);
		SK.setSecondDerivative(PED.getSecondDerivative(), PED.getMinSecondD(), PED.getMaxSecondD());

		T MinT = 87,		MaxT = 255; // CV (D1-SRS01)
//		T MinT = 73,		MaxT = 114; // LZ (D1-SRS02)
//		T MinT = 71,		MaxT = 104; // RK (D2-SRS01)
//		T MinT = 74,		MaxT = 104; // Patient 02

		cout << "Skeletonization ... " << endl; cout.flush();
		SK.Skeletonize(TargetName_gc, MinT, MaxT);
		
		unsigned char	*FlaggedVoxelVolume_uc = NULL;
		int				*DistanceVolume_i = NULL;
		FlaggedVoxelVolume_uc = SK.getFlaggedVoxelVolume();
		DistanceVolume_i = SK.getDistanceVolume();
		
//		Skeleton.ConnectedComponents(TargetName_gc, MinT, MaxT);

	//------------------------------------------------------------------------------
	Timer_Skeleton.End("Timer: Skeletonization");
	break;
	#endif


	#ifdef	SKELETON_SEEDPTS
	Timer	Timer_Skeleton_SeedPts;
	Timer_Skeleton_SeedPts.Start();
	//------------------------------------------------------------------------------
	// Distance based skeletonization
		cSkeleton_SeedPts<T>	SK_SeedPts;
		
		SK_SeedPts.setData(data, Minf, Maxf);
		SK_SeedPts.setWHD(inWidth_gi, inHeight_gi, inDepth_gi);
		SK_SeedPts.setProbabilityHistogram(Material_Prob, NumFoundInitialValues, Histogram, HistogramFactor);
		SK_SeedPts.setGradient(Filtered_Gradientf, (float)Filtered_Mind, (float)Filtered_Maxd);
		SK_SeedPts.setGradientVectors(Gradient_Vectorsf);
		SK_SeedPts.setSecondDerivative(PED.getSecondDerivative(), PED.getMinSecondD(), PED.getMaxSecondD());
		SK_SeedPts.setSeedPts(SeedPtXYZ_i, NumSeedPts);
		
		printf ("Control: Span XYZ = (%f, %f, %f)\n", SpanX_gf, SpanY_gf, SpanZ_gf); fflush (stdout);
		SK_SeedPts.setXYZSpans(SpanX_gf, SpanY_gf, SpanZ_gf);
		
		cout << "Blood Vessel Extraction ... " << endl; cout.flush();

		// Intensity Ranges:
		// LungMatMin, LungMatMax, MuscleMatMin, MuscleMatMax, VesselMatMin, VesselMatMax
		SK_SeedPts.Skeletonize(TargetName_gc, (T)5, (T)54, (T)55, (T)62, (T)87, (T)255); // CV (D1-SRS01)
//		SK_SeedPts.Skeletonize(TargetName_gc, (T)7, (T)48, (T)49, (T)71, (T)73, (T)114); // LZ (D1-SRS02)
//		SK_SeedPts.Skeletonize(TargetName_gc, (T)5, (T)47, (T)56, (T)62, (T)72, (T)104); // RK (D2-SRS01)

//		SK_SeedPts.Skeletonize(TargetName_gc, (T)5, (T)28, (T)55, (T)66, (T)73, (T)255); // Patient 02
//		SK_SeedPts.Skeletonize(TargetName_gc, (T)2, (T)20, (T)53, (T)71, (T)72, (T)151); // Patient 03
//		SK_SeedPts.Skeletonize(TargetName_gc, (T)4, (T)48, (T)49, (T)67, (T)78, (T)184); // Patient 04
//		SK_SeedPts.Skeletonize(TargetName_gc, (T)3, (T)22, (T)54, (T)70, (T)71, (T)149); // Patient 05

//		SK_SeedPts.ConnectedComponents(TargetName_gc, MinT, MaxT);

	//------------------------------------------------------------------------------
	Timer_Skeleton_SeedPts.End("Timer: Skeletonization");
	break;
	#endif
	
	#ifdef	THINNING
	Timer	Timer_Thinning;
	Timer_Thinning.Start();
	//------------------------------------------------------------------------------
		cThinning<T>	Skeleton;
		Skeleton.setData(data, Minf, Maxf);
		Skeleton.setWHD(inWidth_gi, inHeight_gi, inDepth_gi);
		Skeleton.setProbabilityHistogram(Material_Prob, NumFoundInitialValues, Histogram, HistogramFactor);

//		T MinT = 250,		MaxT = 255; // CC Volume
//		T MinT = 70,		MaxT = 255; // CV (D1-SRS01)
//		T MinT = 99,		MaxT = 255; // Branch & H-Shape & test datasets
//		T MinT = 73,		MaxT = 114; // LZ (D1-SRS02)
//		T MinT = 71,		MaxT = 104; // RK (D2-SRS01)
//		T MinT = 71,		MaxT = 255; // Pat002
//		T MinT = 119,		MaxT = 161; // Engine Outside

		cout << "Thinning ... " << endl; cout.flush();
		Skeleton.Thinning4Subfields(TargetName_gc, MinT, MaxT);

		Skeleton.ConnectedComponents(TargetName_gc, MinT, MaxT);
//		PED.setCCVolume(Skeleton.getCCVolume());
//		PED.CopyEndVoxelLocationsFromThinning(Skeleton.EndVoxelStack_mm);
	//------------------------------------------------------------------------------
	Timer_Thinning.End("Timer: Thinning");
	break;
	#endif


		// 133 177 Blood Vessels of D1-SRS01.rawiv
//		printf ("Control: Start Vessel Quantification \n");
//		fflush(stdout);
//		PED.VesselQuantification(TargetName_gc, (T)133, (T)177); // CV Data, D1-SRS01.rawiv
//		PED.VesselQuantification_Manual(TargetName_gc, (T)133, (T)177); // CV Data, D1-SRS01.rawiv

/*
		ZeroCorssingVolume = PED.BoundaryVoxelExtraction(TargetName_gc, (T)133, (T)177); // CV Data, D1-SRS01.rawiv
		ZeroCorssingVolume = PED.BoundaryVoxelExtraction(TargetName_gc, (T)178, (T)255); // Engine - Inside Valve
		ZeroCorssingVolume = PED.BoundaryVoxelExtraction(TargetName_gc, (T)125, (T)159); // Engine - Outside
		ZeroCorssingVolume = PED.BoundaryVoxelExtraction(TargetName_gc, (T)100, (T)100); // Branch
*/

//		SaveVolume(PED.getSecondDerivative(), PED.getMinSecondD(), PED.getMaxSecondD(), "SecondD");

		
	#ifdef	MARCHING_CUBES_SECONDD
	//------------------------------------------------------------------------------
		// Extracting iso-Surfaces from the second derivatives at zero-crossing locations
		cMC_Geom<float, T>		MC_Second;

		MC_Second.setPEDObject(PED);
		MC_Second.setData(PED.getSecondDerivative(), PED.getMinSecondD(), PED.getMaxSecondD());
//		MC_Second.setData(ZeroCorssingVolume); // Re-computing the min & max values of the data
		
		MC_Second.setWHD(inWidth_gi, inHeight_gi, inDepth_gi); // Setting W H D

		MC_Second.setGradient(Filtered_Gradientf, (float)Filtered_Mind, (float)Filtered_Maxd);
		MC_Second.setGradientVectors(Gradient_Vectorsf);
		MC_Second.setSecondDerivative(PED.getSecondDerivative(), PED.getMinSecondD(), PED.getMaxSecondD());


		// Iso-surface classification
//		int			NumMaterials = 4;		// Engine Data
//		int			Ranges[4][2] = { {0, 15}, {7, 118}, {125, 159}, {178, 255} };

		int			NumMaterials = 1;

		int			Ranges[1][2] = { {178, 255} }; // Engine Inside
//		int			Ranges[1][2] = { {119, 177} }; // Engine Surface
//		int			Ranges[1][2] = { {119, 255} }; // Engine Inside + Surface

//		int			Ranges[1][2] = { {132, 255} }; // D1_SRS01_256.rawiv  Blood vessels
//		int			Ranges[1][2] = { {98, 135} }; // D1_SRS01_256.rawiv  Soft Skins

//		int			Ranges[1][2] = { {128, 156} }; // Brain Web Whitematter

/*
		MC_Second.setNumMaterials(NumMaterials);
		for (i=0; i<NumMaterials; i++) {
			MC_Second.setAMaterialRange(i, Ranges[i][0], Ranges[i][1]);
		}
*/
		cout << "Control: Start to extract geometries from the second derivative" << endl;

		// Iso-value should be between 0.0 for zero-crosing surface
//		MC_Second.IsosurfaceGenerationFromSecondD();
		
		MC_Second.ExtractingIsosurfacesFromSecondD((float)0.0, (float)0.0, (float)256.0);
		cout << "Control: The end of extracting geometries from the second derivative" << endl;

/*
		cout << "Triangle Classification" << endl;
		MC_Second.TriangleClassification();
		cout << "The End of the Triangle Classification" << endl;
*/

/*		
		for (i=0; i<NumMaterials; i++) {
			MC_Second.SaveMatGeometry_RAW(TargetName_gc, i);
		}
*/


	//	MC_Second.SaveGeometry_VRML(TargetName_gc, VRML_LINE);
	//	MC_Second.SaveGeometry_VRML(TargetName_gc, VRML_FACE);
	
		MC_Second.SaveGeometry_RAW(TargetName_gc, "Mat00");

		MC_Second.Destroy();

	//------------------------------------------------------------------------------
	#endif


	#ifdef	TF_GENERATION
	Timer	Timer_TF;
	Timer_TF.Start();
	//------------------------------------------------------------------------------
		

/*
		// Computing only distance volume
		Timer	Timer_Distance;
		Timer_Distance.Start();
		PED.ComputeDistanceVolume((double)0.1, TargetName_gc);
		Timer_Distance.End("Timer: Distance Computation & Save the Volume");
*/


		// Computing Distance & IG Histogram Graphs
		// Saving the volume, DistanceVolume_f & GMVolume_uc
		int		WHD_i = inWidth_gi*inHeight_gi*inDepth_gi;
		float	MinDist_f = FLT_MAX;
		float	MaxDist_f = FLT_MIN;
		unsigned char	*DistanceVolume_uc = new unsigned char [WHD_i];
		unsigned char	*GMVolume_uc = new unsigned char [WHD_i];
		Timer	Timer_Distance;
		Timer_Distance.Start();
		PED.Compute_Dist_GM((double)0.1, MinDist_f, MaxDist_f, 
							DistanceVolume_uc, GMVolume_uc, TargetName_gc);
		Timer_Distance.End("Timer: Distance Computation and Histograms");

	#ifdef	SAVE_DISTANCE_GMHIT_RAWV
		SaveVolumeRawV(data, GMVolume_uc, DistanceVolume_uc, TargetName_gc);
	#endif

		delete GMVolume_uc;
		delete DistanceVolume_uc;
		
/*
		Timer	Timer_CCVolume;
		Timer_CCVolume.Start();
		PED.ComputeConnectedSurfaceVolume2((double)0.1, TargetName_gc);
		Timer_CCVolume.End("Timer: Computing Connected Surface Volume");
*/


/*
		// Kindlmann's Sigma Computation
		Timer	Timer_SigmaEvaluation;
		Timer_SigmaEvaluation.Start();
		// GradThreshold_d, NumElements_i, DoSigmaEvaluation_i, *TargetFileName_c
		PED.HistoVolumeSigma_Evaluation((double)0.01, 256, 1, TargetName_gc);
		Timer_SigmaEvaluation.End("Timer: Distance Computation");
*/

	#ifdef	SAVE_DISTANCE_GMHIT_RAWIV
		float	*DistanceVolume_f;
		DistanceVolume_f = PED.ComputeDistanceVolume2((double)0.1, MinDist_f, MaxDist_f, TargetName_gc, 256);
	#endif
/*		
		float	*DistVolumeAbs_f = new float [inWidth_gi*inHeight_gi*inDepth_gi];
		for (i=0; i<inWidth_gi*inHeight_gi*inDepth_gi; i++) {
			DistVolumeAbs_f[i] = fabsf(DistanceVolume_f[i]);
		}
		printf ("Min & Max Distace = %f %f\n", (float)0.0, (MaxDist_f<fabs(MinDist_f)) ? fabs(MinDist_f):MaxDist_f);
//		SaveVolume(DistVolumeAbs_f, MinDist_f, MaxDist_f, "Distance");
*/
//		PED.DisplayIGS(0, inWidth_gi, 0, inHeight_gi, 1, 1, DistanceVolume_f);
//		delete [] DistanceVolume_f;


//		PED.Connected_Positive_SecondD_Voxels_RunSave(true);
//		PED.ComputeDistanceHistoAt((double)125.0, (double)100.0, DistanceVolume_f, MinDist_f, MaxDist_f);


//		int		*TransFunc = new int [256*256*4];
//		PED.ComputeTF(TargetName_gc, (T)136, (T)255, TransFunc); // Lung for bones and heart

//		PED.InitTF(NumFoundInitialValues);

//		PED.AdjustingBoundaries(TargetName_gc);
	//	for (i=0; i<NumFoundInitialValues; i++) {
	//		PED.ComputeIGGraph(TargetName_gc, i, 512);
	//	}
	//	PED.ComputeIGGraphAllMaterials(TargetName_gc, 512);
	//	PED.ComputeIGGraphBoundaries(TargetName_gc, 512);
	//	PED.ComputeIHGraphAllMaterials(TargetName_gc, 512);
	//	PED.ComputeH_vg(TargetName_gc, 512);
	//	PED.ComputeTF(TargetName_gc, 5, TransFunc); // Material Number & TF Table
	//------------------------------------------------------------------------------
	Timer_TF.End("Timer: TF Generation");
	break;
	#endif


#endif	// The end of PE_DETECTION

		//------------------------------------------------------------------------------
		delete [] Material_Prob;
	}
	
	clusters.Destroy();


	delete [] data;
	delete [] Filtered_Gradientf;
	delete [] Histogram;
	delete [] HistogramOrg;

//==================================================================================
	Timer_Total.End("Timer: Total Execution time");
//==================================================================================
	
}


template<class T>
int ReadInitialValues(char *IValueFileName, int NumClusters, int& NumIValues_ret, T *IValues_ret)
{
	fstream		IValue_File;
	filebuf 	*fb_IValue_File;
	int 		i, MaxNumIValues, Tempi;
	T 			*IValues = NULL;
	int 		IValueLoc[3];


	IValue_File.open (IValueFileName, ifstream::in);
	fb_IValue_File = IValue_File.rdbuf();
	if (!fb_IValue_File->is_open()) {
		cout << "The initial value file cannot be open : " << IValueFileName << endl;
		exit(1);
	}

	IValue_File >> MaxNumIValues;
	IValues = new T [MaxNumIValues];
	
	IValue_File.seekg (0, ios::beg);
	do {
		IValue_File >> NumIValues_ret;
		if (NumIValues_ret < NumClusters) {
			cout << "The minimum number of initial values is " << NumIValues_ret << endl;
			cout << "The number of material ("<< NumClusters;
			cout << ") should be less than the minimum number" <<endl;
			return false;
		}

		for (i=0; i<NumIValues_ret; i++) {
			if (sizeof(IValues[i])==1) {
				IValue_File >> Tempi;
				IValues[i] = (unsigned char)Tempi;
			}
			else IValue_File >> IValues[i];
			IValue_File >> IValueLoc[0];
			IValue_File >> IValueLoc[1];
			IValue_File >> IValueLoc[2];
		}
		if (NumIValues_ret==NumClusters) break;
	} while (1);
	IValue_File.close();

	for (i=0; i<NumIValues_ret; i++) IValues_ret[i]  = IValues[i];
	delete [] IValues;

	return true;
}


int* ReadSeedPts(char *IValueFileName, int& NumSeedPts_Ret)
{
	fstream		IValue_File;
	filebuf 	*fb_IValue_File;
	int 		i, MaxNumIValues, NumIValues;
	float		*IValues_f = NULL;
	int 		IValueLoc[3];


	printf ("Read_SeedPts: File Name = %s\n", IValueFileName); fflush (stdout);

	IValue_File.open (IValueFileName, ifstream::in);
	fb_IValue_File = IValue_File.rdbuf();
	if (!fb_IValue_File->is_open()) {
		cout << "The initial value file cannot be open : " << IValueFileName << endl;
		exit(1);
	}

	IValue_File >> MaxNumIValues;
	IValues_f = new float [MaxNumIValues];
	
	IValue_File.seekg (0, ios::beg);
	do {
		IValue_File >> NumIValues;

		for (i=0; i<NumIValues; i++) {
			IValue_File >> IValues_f[i];
			IValue_File >> IValueLoc[0];
			IValue_File >> IValueLoc[1];
			IValue_File >> IValueLoc[2];
		}
		if (NumIValues==2) break;
	} while (1);
	delete [] IValues_f;

	
	IValue_File >> NumSeedPts_Ret;
	
	printf ("Read_SeedPts: # seed pts = %d\n", NumSeedPts_Ret); fflush (stdout);
	if (NumSeedPts_Ret==0) return NULL;

	int *SeedPts_i = new int [NumSeedPts_Ret*3];
	for (i=0; i<NumSeedPts_Ret; i++) {
		IValue_File >> SeedPts_i[i*3 + 0];
		IValue_File >> SeedPts_i[i*3 + 1];
		IValue_File >> SeedPts_i[i*3 + 2];
	}

	IValue_File.close();

	return SeedPts_i;
}


int FindAMaxInitialValue(char *IValueFileName)
{
	fstream		IValue_File;
	filebuf 	*fb_IValue_File;
	int 		MaxNumIValues;


	IValue_File.open (IValueFileName, ifstream::in);
	fb_IValue_File = IValue_File.rdbuf();
	if (!fb_IValue_File->is_open()) {
		cout << "The initial value file cannot be open : " << IValueFileName << endl;
		exit(1);
	}
	IValue_File >> MaxNumIValues;
	IValue_File.close();

	return MaxNumIValues;
}


void SaveClassification(float *Material_Prob, float Minf, float Maxf, int WindowSize, int NumMaterials, char *Name)
{
	FILE			*out_st;
	char			OutFileName[200];
	unsigned char	*out_datauc;
	double			TempRd, TempGd, TempBd;
	double			WeightRGB[3][3] = {	{1.0, 0.0, 0.0}, {0.0, 1.0, 0.0}, {0.0, 0.0, 1.0} };
	int				i, j, k, m, loc[5];
	int				WtimesH, WHD;


	printf ("Minf = %f, Maxf = %f\n", Minf, Maxf);
	
	WHD = inWidth_gi*inHeight_gi*inDepth_gi;
	WtimesH = inWidth_gi*inHeight_gi;

	out_datauc = new unsigned char [WtimesH*3];

	if (NumLeaping_gi > 1) k=NumLeaping_gi;
	else k=0;
	for (; k<inDepth_gi; k+=NumLeaping_gi) {	// Jump to next slice
	
		for (j=0; j<inHeight_gi; j++) {
			for (i=0; i<inWidth_gi; i++) {
				TempRd = (double)0.0;
				TempGd = (double)0.0;
				TempBd = (double)0.0;
				for (m=0; m<NumMaterials; m++) {
					loc[0] = m*WHD + k*WtimesH + j*inWidth_gi + i;
					TempRd += (((double)m+1)/NumMaterials*Material_Prob[loc[0]]*WeightRGB[m%3][0]);
					TempGd += (((double)m+1)/NumMaterials*Material_Prob[loc[0]]*WeightRGB[m%3][1]);
					TempBd += (((double)m+1)/NumMaterials*Material_Prob[loc[0]]*WeightRGB[m%3][2]);
				}
				loc[1] = j*inWidth_gi*3 + i*3;
				out_datauc[loc[1]+0] = (unsigned char)(TempRd * 255.0);
				out_datauc[loc[1]+1] = (unsigned char)(TempGd * 255.0);
				out_datauc[loc[1]+2] = (unsigned char)(TempBd * 255.0);
			}
		}
		
		//------------------------------------------------------------------------
		// Classified Slice
		if (inDepth_gi==1 && NumLeaping_gi==1) 
			sprintf (OutFileName, "%s-W%02d-Mat%02d%s.ppm", TargetName_gc, WindowSize, NumMaterials, Name);
		else sprintf (OutFileName, "%s%04d-W%02d-Mat%02d%s.ppm", TargetName_gc, k, WindowSize, NumMaterials, Name);
		printf ("Output File = %s\n", OutFileName); fflush (stdout);
		
		if ((out_st=fopen(OutFileName, "w"))==NULL) {
			printf ("Could not open %s\n", OutFileName);
			exit(1);
		}
		fprintf (out_st, "P3\n%d %d\n", inWidth_gi, inHeight_gi);
		fprintf (out_st, "%d\n", 255);

		for (i=0; i<WtimesH; i++) {
			fprintf (out_st, "%d %d %d\n", out_datauc[i*3], out_datauc[i*3+1], out_datauc[i*3+2]);
		}
		fclose (out_st);
	}

	delete [] out_datauc;
}


template<class T>
void SaveClassificationWithHistogram(T data, float *Material_Prob, float Minf, float Maxf, int* Histo, float HistoF, 
										int WindowSize, int NumMaterials, char *Name)
{

	FILE			*out_st;
	char			OutFileName[200];
	unsigned char	*out_datauc;
	double			TempRd, TempGd, TempBd;
	double			WeightRGB[3][3] = {	{1.0, 0.0, 0.0}, {0.0, 1.0, 0.0}, {0.0, 0.0, 1.0} };
	int				i, j, k, m, loc[5];
	int				WtimesH, WHD;
	int				DataValueinHistogram;
	double			Probability;

	WHD = inWidth_gi*inHeight_gi*inDepth_gi;
	WtimesH = inWidth_gi*inHeight_gi;

	out_datauc = new unsigned char [WtimesH*3];

	if (NumLeaping_gi > 1) k=NumLeaping_gi;
	else k=0;
	for (; k<inDepth_gi; k+=NumLeaping_gi) {	// Jump to next slice
	
		for (j=0; j<inHeight_gi; j++) {
			for (i=0; i<inWidth_gi; i++) {
				TempRd = (double)0.0;
				TempGd = (double)0.0;
				TempBd = (double)0.0;
				for (m=0; m<NumMaterials; m++) {
					loc[0] = m*WHD + k*WtimesH + j*inWidth_gi + i;
					loc[2] = k*WtimesH + j*inWidth_gi + i;
					
					DataValueinHistogram = (int)(((double)data[loc[2]]-Minf)*HistoF);
					Probability = Material_Prob[DataValueinHistogram*NumMaterials + m];
//					Probability = Material_Prob[m*(int)((Maxf-Minf)*HistoF) + DataValueinHistogram];

					TempRd += (((double)m+1)/NumMaterials*Probability*WeightRGB[m%3][0]);
					TempGd += (((double)m+1)/NumMaterials*Probability*WeightRGB[m%3][1]);
					TempBd += (((double)m+1)/NumMaterials*Probability*WeightRGB[m%3][2]);
				}
				loc[1] = j*inWidth_gi*3 + i*3;
				out_datauc[loc[1]+0] = (unsigned char)(TempRd * 255.0);
				out_datauc[loc[1]+1] = (unsigned char)(TempGd * 255.0);
				out_datauc[loc[1]+2] = (unsigned char)(TempBd * 255.0);
			}
		}
		
		//------------------------------------------------------------------------
		// Classified Slice
		if (inDepth_gi==1 && NumLeaping_gi==1) 
			sprintf (OutFileName, "%s-W%02d-Mat%02d%s.ppm", TargetName_gc, WindowSize, NumMaterials, Name);
		else sprintf (OutFileName, "%s%04d-W%02d-Mat%02d%s.ppm", TargetName_gc, k, WindowSize, NumMaterials, Name);
		printf ("Output File = %s\n", OutFileName); fflush (stdout);
		
		if ((out_st=fopen(OutFileName, "w"))==NULL) {
			printf ("Could not open %s\n", OutFileName);
			exit(1);
		}
		fprintf (out_st, "P3\n%d %d\n", inWidth_gi, inHeight_gi);
		fprintf (out_st, "%d\n", 255);

		for (i=0; i<WtimesH; i++) {
			fprintf (out_st, "%d %d %d\n", out_datauc[i*3], out_datauc[i*3+1], out_datauc[i*3+2]);
		}
		fclose (out_st);
	}

	delete [] out_datauc;

}


template<class T> 
void SaveOrigSlices(T *data, float Minf, float Maxf, int WindowSize, int NumMaterials)
{
	FILE			*out_st;
	char			OutFileName[200];
	unsigned char	Tempuc;
	double			Tempd;
	int				i, k, loc[5];
	int				WtimesH;


	WtimesH = inWidth_gi*inHeight_gi;

	if (NumLeaping_gi>1 && inDepth_gi>1) k=NumLeaping_gi;
	else k=0;
	for (; k<inDepth_gi; k+=NumLeaping_gi) {	// Jump to next slice


		//-----------------------------------------------------------------------
		// Original Slice
		if (inDepth_gi==1) {
			sprintf (OutFileName, "%sOrg.ppm", TargetName_gc);
		}
		else {
			sprintf (OutFileName, "%s%04dOrg.ppm", TargetName_gc, k);
		}
		printf ("Output File = %s\n", OutFileName); fflush (stdout);
		if ((out_st=fopen(OutFileName, "w"))==NULL) {
			printf ("Could not open %s\n", OutFileName);
			exit(1);
		}
		fprintf (out_st, "P3\n%d %d\n", inWidth_gi, inHeight_gi);
		fprintf (out_st, "%d\n", 255);
		for (i=0; i<WtimesH; i++) {

			loc[0] = k*WtimesH + i;
			Tempd = (double)data[loc[0]];
			Tempd = (Tempd-Minf)/((double)Maxf-Minf)*255.0;
			Tempuc = (unsigned char)Tempd;
			
			fprintf (out_st, "%d %d %d\n", Tempuc, Tempuc, Tempuc);
		}
		fflush(out_st);
		fclose(out_st);
		
#ifdef	INTENSITY_GRAPH
		if (inDepth_gi==1 && NumLeaping_gi==1) {
			sprintf (OutFileName, "%sOrg_Graph.txt", TargetName_gc);
		}
		else {
			sprintf (OutFileName, "%s%04dOrg_Graph.txt", TargetName_gc, k);
		}
		printf ("Output File = %s\n", OutFileName); fflush (stdout);
		if ((out_st=fopen(OutFileName, "w"))==NULL) {
			printf ("Could not open %s\n", OutFileName);
			exit(1);
		}
		for (i=0; i<inWidth_gi; i++) {
			loc[0] = k*WtimesH + (inHeight_gi/2-2)*inWidth_gi + i;
			loc[1] = k*WtimesH + (inHeight_gi/2-1)*inWidth_gi + i;
			loc[2] = k*WtimesH + (inHeight_gi/2+0)*inWidth_gi + i;
			loc[3] = k*WtimesH + (inHeight_gi/2+1)*inWidth_gi + i;
			loc[4] = k*WtimesH + (inHeight_gi/2+2)*inWidth_gi + i;
			fprintf (out_st, "%d %f %f %f %f %f\n", i, 
						(float)data[loc[0]], (float)data[loc[1]], (float)data[loc[2]], (float)data[loc[3]], (float)data[loc[4]]);
		}
		fflush(out_st);
		fclose(out_st);
#endif

	}
}

template<class T> 
void SaveOrigSlicesWithInitialValues(T *data, float Minf, float Maxf, int NumInitialValues, int *InitialVLocations)
{
#ifdef		SAVE_ORIGINAL_SLICES_AND_INITIAL_VALUES
	FILE			*out_st;
	char			OutFileName[200];
	unsigned char	Tempuc;
	double			Tempd;
	int				i, j, k, m, loc[5];
	int				InitialLocation, WtimesH;
	int				*ZValues, NumZValues;
	
	
	WtimesH = inWidth_gi*inHeight_gi;
	
	ZValues = new int [NumInitialValues];
	for (i=0; i<NumInitialValues; i++) {
		ZValues[i] = InitialVLocations[i*3 + 2];
	}
	for (i=0; i<NumInitialValues-1; i++) {
		for (j=i+1; j<NumInitialValues; j++) {
			if (ZValues[i] == ZValues[j]) ZValues[j] = -1;
		}
	}
	for (j=0, i=0; i<NumInitialValues; i++) {
		if (ZValues[i] > -1) ZValues[j++] = ZValues[i];
	}
	NumZValues = j;
	printf ("Num Z Values = %d\n", NumZValues);
	for (i=0; i<NumZValues; i++) {
		printf ("Z Value[%d] = %d\n", i, ZValues[i]);
	}
	fflush (stdout);


	for (j=0; j<NumZValues; j++) {

		k = ZValues[j];
		//-----------------------------------------------------------------------
		// Original Slice
		int		InitialValueLoc[5], Initi;
		if (inDepth_gi==1) {
			sprintf (OutFileName, "%s-%02dOrgInit.ppm", TargetName_gc, NumInitialValues);
		}
		else {
			sprintf (OutFileName, "%s_%03d-%02dOrgInit.ppm", TargetName_gc, k, NumInitialValues);
		}
		printf ("Output File = %s\n", OutFileName); fflush (stdout);
		if ((out_st=fopen(OutFileName, "w"))==NULL) {
			printf ("Could not open %s\n", OutFileName);
			exit(1);
		}
		fprintf (out_st, "P3\n%d %d\n", inWidth_gi, inHeight_gi);
		fprintf (out_st, "%d\n", 255);
		for (i=0; i<WtimesH; i++) {
			InitialLocation = FALSE;
			for (m=0; m<NumInitialValues; m++) {
				InitialValueLoc[0] = InitialVLocations[m*3+1]*inWidth_gi + InitialVLocations[m*3];
				if (InitialVLocations[m*3]>=1 && k==InitialVLocations[m*3+2])
					InitialValueLoc[1] = InitialVLocations[m*3+1]*inWidth_gi + InitialVLocations[m*3]-1;
				else InitialValueLoc[1] = -1;
				if (InitialVLocations[m*3]<inWidth_gi-1 && k==InitialVLocations[m*3+2])
					InitialValueLoc[2] = InitialVLocations[m*3+1]*inWidth_gi + InitialVLocations[m*3]+1;
				else InitialValueLoc[2] = -1;
				if (InitialVLocations[m*3+1]>=1 && k==InitialVLocations[m*3+2])
					InitialValueLoc[3] = (InitialVLocations[m*3+1]-1)*inWidth_gi + InitialVLocations[m*3];
				else InitialValueLoc[3] = -1;
				if (InitialVLocations[m*3+1]<inHeight_gi-1 && k==InitialVLocations[m*3+2])
					InitialValueLoc[4] = (InitialVLocations[m*3+1]+1)*inWidth_gi + InitialVLocations[m*3];
				else InitialValueLoc[4] = -1;
				for (Initi=0; Initi<5; Initi++) {
					if (InitialValueLoc[Initi]==-1) continue;
					if (i == InitialValueLoc[Initi] && k==InitialVLocations[m*3+2]) {
						InitialLocation = TRUE;
						break;
					}
				}
			}
			loc[0] = k*WtimesH + i;
			Tempd = (double)data[loc[0]];
			Tempd = (Tempd-Minf)/((double)Maxf-Minf)*255.0;
			Tempuc = (unsigned char)Tempd;
			
			if (InitialLocation) fprintf (out_st, "%d %d %d\n", 255, 0, 0);
			else fprintf (out_st, "%d %d %d\n", Tempuc, Tempuc, Tempuc);
		}
	}
	fflush(out_st);
	fclose(out_st);
	delete [] ZValues;
#endif
}

		
void SaveGradient(float *Gradientf, float *Filtered_Gradientf, double GradientMind, double GradientMaxd, int WindowSize, int NumMaterials)
{
	FILE			*out_st;
	char			OutFileName[200];
	unsigned char	Tempuc;
	double			Tempd;
	int				i, k, loc[5];
	int				WtimesH;


	WtimesH = inWidth_gi*inHeight_gi;

	printf ("WindowSize = %d, NumMaterials %d\n", WindowSize, NumMaterials);
	
	if (NumLeaping_gi > 1) k=NumLeaping_gi;
	else k=0;
	for (; k<inDepth_gi; k+=NumLeaping_gi) {	// Jump to next slice

		//-----------------------------------------------------------------------
		// Gradient Magnitudes
		if (inDepth_gi==1 && NumLeaping_gi==1) {
			sprintf (OutFileName, "%sGrad.ppm", TargetName_gc);
		}
		else {
			sprintf (OutFileName, "%s%04dGrad.ppm", TargetName_gc, k);
		}		

		if ((k==0 || k==inDepth_gi-1) && inDepth_gi>1) {  }
		else {
			printf ("Output File = %s\n", OutFileName); fflush (stdout);
			if ((out_st=fopen(OutFileName, "w"))==NULL) {
				printf ("Could not open %s\n", OutFileName);
				exit(1);
			}
			fprintf (out_st, "P3\n%d %d\n", inWidth_gi, inHeight_gi);
			fprintf (out_st, "%d\n", 255);
			
			GradientMaxd = 700.0;
			for (i=0; i<WtimesH; i++) {
				loc[0] = k*WtimesH + i;
				Tempd = ((double)Gradientf[loc[0]]-GradientMind)/(GradientMaxd-GradientMind)*255.0;
				
				if (Tempd>255) Tempd=255;
				
				Tempuc = (unsigned char)Tempd;
				fprintf (out_st, "%d %d %d\n", Tempuc, Tempuc, Tempuc);
			}
			fclose(out_st);
		}

		//-----------------------------------------------------------------------
		// Filtered Gradient Magnitudes
		if (inDepth_gi==1 && NumLeaping_gi==1) {
			sprintf (OutFileName, "%sGrad_Filtered.ppm", TargetName_gc);
		}
		else {
			sprintf (OutFileName, "%s%04dGrad_Filtered.ppm", TargetName_gc, k);
		}		

		if ((k==0 || k==inDepth_gi-1) && inDepth_gi>1) {  }
		else {
			printf ("Output File = %s\n", OutFileName); fflush (stdout);
			if ((out_st=fopen(OutFileName, "w"))==NULL) {
				printf ("Could not open %s\n", OutFileName);
				exit(1);
			}
			fprintf (out_st, "P3\n%d %d\n", inWidth_gi, inHeight_gi);
			fprintf (out_st, "%d\n", 255);
			
			GradientMaxd = 700.0;
			for (i=0; i<WtimesH; i++) {
				loc[0] = k*WtimesH + i;
				Tempd = ((double)Filtered_Gradientf[loc[0]]-GradientMind)/(GradientMaxd-GradientMind)*255.0;
				
				if (Tempd>255) Tempd=255;
				
				Tempuc = (unsigned char)Tempd;
				fprintf (out_st, "%d %d %d\n", Tempuc, Tempuc, Tempuc);
			}
			fclose(out_st);
		}


#ifdef	GRADIENT_GRAPH
		int		WHD = inWidth_gi*inHeight_gi*inDepth_gi;
		for (i=0; i<WHD; i++) {
			if (Gradientf[i]>1000.0) Gradientf[i]=1000.0;
		}

		if (inDepth_gi==1 && NumLeaping_gi==1) {
			sprintf (OutFileName, "%sGrad_Graph.txt", TargetName_gc);
		}
		else {
			sprintf (OutFileName, "%s%04dGrad_Graph.txt", TargetName_gc, k);
		}		
		printf ("Output File = %s\n", OutFileName); fflush (stdout);
		if ((out_st=fopen(OutFileName, "w"))==NULL) {
			printf ("Could not open %s\n", OutFileName);
			exit(1);
		}
		for (i=0; i<inWidth_gi; i++) {
			loc[0] = k*WtimesH + (inHeight_gi/2-2)*inWidth_gi + i;
			loc[1] = k*WtimesH + (inHeight_gi/2-1)*inWidth_gi + i;
			loc[2] = k*WtimesH + (inHeight_gi/2+0)*inWidth_gi + i;
			loc[3] = k*WtimesH + (inHeight_gi/2+1)*inWidth_gi + i;
			loc[4] = k*WtimesH + (inHeight_gi/2+2)*inWidth_gi + i;
			fprintf (out_st, "%d %f %f %f %f %f\n", i, 
					Gradientf[loc[0]], Gradientf[loc[1]], Gradientf[loc[2]], Gradientf[loc[3]], Gradientf[loc[4]]);
		}
		fclose(out_st);
		

		for (i=0; i<WHD; i++) {
			if (Filtered_Gradientf[i]>1000.0) Filtered_Gradientf[i]=1000.0;
		}
		if (inDepth_gi==1 && NumLeaping_gi==1) {
			sprintf (OutFileName, "%sGrad_Filtered_Graph.txt", TargetName_gc);
		}
		else {
			sprintf (OutFileName, "%s%04dGrad_Filtered_Graph.txt", TargetName_gc, k);
		}		
		printf ("Output File = %s\n", OutFileName); fflush (stdout);
		if ((out_st=fopen(OutFileName, "w"))==NULL) {
			printf ("Could not open %s\n", OutFileName);
			exit(1);
		}
		for (i=0; i<inWidth_gi; i++) {
			loc[0] = k*WtimesH + (inHeight_gi/2-2)*inWidth_gi + i;
			loc[1] = k*WtimesH + (inHeight_gi/2-1)*inWidth_gi + i;
			loc[2] = k*WtimesH + (inHeight_gi/2+0)*inWidth_gi + i;
			loc[3] = k*WtimesH + (inHeight_gi/2+1)*inWidth_gi + i;
			loc[4] = k*WtimesH + (inHeight_gi/2+2)*inWidth_gi + i;
			fprintf (out_st, "%d %f %f %f %f %f\n", i, 
					Filtered_Gradientf[loc[0]], Filtered_Gradientf[loc[1]], Filtered_Gradientf[loc[2]], 
					Filtered_Gradientf[loc[3]], Filtered_Gradientf[loc[4]]);
		}
		fclose(out_st);
#endif

	}
	
}


template<class T> 
void SaveHistogram(float *Material_Prob, int *Histogram, T *data, float Minf, float Maxf, float HistoF,
					int WindowSize, int NumMaterials, char *name)
{
	FILE	*out_st;
	char	OutFileName[500];
	int		i, m, index, WHD;
	float	*MaterialNumf = new float[(int)((Maxf-Minf)*HistoF+1)*NumMaterials];
	int		*HistogramOfProbabilities = new int [11*NumMaterials+1]; // 0, 1, ... , 10


	WHD = inWidth_gi*inHeight_gi*inDepth_gi;
	
	// Histogram for probabilities
	for (i=0; i<11*NumMaterials; i++) HistogramOfProbabilities[i]=0;
	for (i=0; i<WHD; i++) {
		for (m=0; m<NumMaterials; m++) {
			index = (int)(Material_Prob[m*WHD + i]*10.0);
			HistogramOfProbabilities[m*11 + index]++;
		}
	}

	// Histogram for intensity values
	for (i=0; i<(int)((Maxf-Minf)*HistoF)*NumMaterials; i++) {
		MaterialNumf[i]=0.0;
	}
	for (i=0; i<WHD; i++) {
		for (m=0; m<NumMaterials; m++) {
			if (Material_Prob[m*WHD + i]>0.0) { // 1%
				MaterialNumf[(int)((data[i]-Minf)*HistoF)*NumMaterials + m]+=Material_Prob[m*WHD + i];
			}
		}
	}
#ifdef	SAVE_Histogram_File	
	sprintf (OutFileName, "%s-Mat%02d%s.Histo", TargetName_gc, NumMaterials, name);
	printf ("Histogram File = %s\n", OutFileName); fflush (stdout);
	if ((out_st=fopen(OutFileName, "wt"))==NULL) {
		printf ("Could not open %s\n", OutFileName);
		exit(1);
	}
#endif
/*
	for (i=0; i<11*NumMaterials; i++) {
		if (i%11==0) fprintf (out_st, "\nMaterial = %d\n", i/11);
		fprintf (out_st, "Prob[%4.1f] = %d\n", (float)(i%11)/10.0, HistogramOfProbabilities[i]);
	}
*/

	for (i=0; i<(int)((Maxf-Minf)*HistoF)-1; i++) {
		if (Histogram[i]>10e-3) {
			if (fabsf(HistoF)<1e-3)
				fprintf (out_st, "%6d ", (int)((float)i+Minf));
			else fprintf (out_st, "%f ", (float)i/HistoF+Minf);
			
			for (m=0; m<NumMaterials; m++) {
				fprintf (out_st, "%9.4f ", MaterialNumf[i*NumMaterials + m]);
			}
			fprintf (out_st, "     %d\n", Histogram[i]);
		}
	}
	fflush (out_st);
	fclose (out_st);
	delete [] MaterialNumf;
	delete [] HistogramOfProbabilities;

}

template<class T>
void SaveRangesWithHistogram(T *data, float *Material_Prob, float Minf, float Maxf, int *Histo, 
				float HistoF, int WindowSize, int NumClusters, char *Name)
{

	FILE		*out_st;
	char		OutFileName[500];
	int			i, j, loc[2];
	double		TempRd, TempGd, TempBd;
	double		WeightRGB[3][3] = {	{1.0, 0.0, 0.0}, {0.0, 1.0, 0.0}, {0.0, 0.0, 1.0} };


	sprintf (OutFileName, "%s-Mat%02d%s.Histo", TargetName_gc, NumClusters, Name);
	printf ("Histogram File = %s\n", OutFileName); fflush (stdout);
	if ((out_st=fopen(OutFileName, "wt"))==NULL) {
		printf ("Could not open %s\n", OutFileName);
		exit(1);
	}

	for (i=0; i<(int)((Maxf-Minf)*HistoF); i++) {
		if (Histo[i]>0) fprintf (out_st, "%12.4f ", (float)i/HistoF + Minf);

		TempRd = (double)0.0;
		TempGd = (double)0.0;
		TempBd = (double)0.0;

		for (j=0; j<NumClusters; j++) {

			loc[0]= i*NumClusters + j;
			if (Histo[i]>0) {
				if (Material_Prob[loc[0]]>=0.0)
					fprintf (out_st, " %9.2f", Material_Prob[loc[0]]*Histo[i]);
				else fprintf (out_st, " ...... ");

				TempRd += (((double)j+1)/NumClusters*Material_Prob[i*NumClusters + j]*WeightRGB[j%3][0]);
				TempGd += (((double)j+1)/NumClusters*Material_Prob[i*NumClusters + j]*WeightRGB[j%3][1]);
				TempBd += (((double)j+1)/NumClusters*Material_Prob[i*NumClusters + j]*WeightRGB[j%3][2]);
				
			}
		}
		if (Histo[i]>0) {
			fprintf (out_st, " %12d  ", Histo[i]);
			fprintf (out_st, " %4d %4d %4d\n", (int)(TempRd*255), (int)(TempGd*255), (int)(TempBd*255));
		}
	}
	fflush (out_st);
	fclose (out_st);

}

	
template<class T>
void SaveMembershipValues(T *data, float *Material_Prob, float Minf, float Maxf, int *Histo, 
							float HistoF, int NumClusters)
{
	FILE		*out_st;
	char		OutFileName[500];
	int			i, j, loc[2];

	printf ("data[0] = %f\n", (float)data[0]);
	printf ("Histo[0] = %f\n", (float)Histo[0]);
	
	sprintf (OutFileName, "%s-Mat%02dProb.txt", TargetName_gc, NumClusters);
	printf ("Histogram File = %s\n", OutFileName); fflush (stdout);
	if ((out_st=fopen(OutFileName, "wt"))==NULL) {
		printf ("Could not open %s\n", OutFileName);
		exit(1);
	}

	fprintf (out_st, "%12.4f %12.4f\n", MinOrg_gd, MaxOrg_gd);
	for (i=0; i<=(int)((Maxf-Minf)*HistoF); i++) {
		fprintf (out_st, "%12.4f ", (float)i/HistoF + Minf);
		for (j=0; j<NumClusters; j++) {
			loc[0]= i*NumClusters + j;
			fprintf (out_st, " %8.4f", Material_Prob[loc[0]]);
		}
		fprintf (out_st, "\n");
	}
	fflush (out_st);
	fclose (out_st);

}

	
template<class T> 
void SaveMaterialVolume_Boundary(float *Material_Prob, T *data, float Minf, float Maxf, int WindowSize, 
									int NumMaterials, char *Name)
{
	T		*Material_Volume;
	char	OutFileName[200];
	int     binfile_fd2;
	int		k, m, WHD;
	float	SliceMinf, SliceMaxf;


	WHD = inWidth_gi*inHeight_gi*inDepth_gi;
	Material_Volume = new T [WHD];
	
	for (m=0; m<NumMaterials; m++) {

		SliceMinf = 99999;
		SliceMaxf = -99999;
		for (k=0; k<WHD; k++) {
			if (Material_Prob[m*WHD + k]>0.01) { // 1%
				Material_Volume[k] = (T)(Maxf*Material_Prob[m*WHD + k]);
			}
			else Material_Volume[k] = (T)(Maxf*0.01);
			if (SliceMinf > (float)Material_Volume[k]) SliceMinf = (float)Material_Volume[k];
			if (SliceMaxf < (float)Material_Volume[k]) SliceMaxf = (float)Material_Volume[k];
		}

		if (RawivHeader_guc!=NULL) {
			sprintf (OutFileName, "%s%02d-W%02d-Mat%02d%s.rawiv", TargetName_gc, m, WindowSize, NumMaterials, Name);
		}
		else {
			sprintf (OutFileName, "%s%02d-W%02d-Mat%02d%s.raw", TargetName_gc, m, WindowSize, NumMaterials, Name);
		}
		printf ("Output File = %s\n", OutFileName); fflush (stdout);

		if ((binfile_fd2 = open (OutFileName, O_CREAT | O_WRONLY | O_TRUNC)) < 0) {
			printf ("could not open %s\n", OutFileName);
			exit(1);
		}
		if (RawivHeader_guc!=NULL) {
			if (write(binfile_fd2, RawivHeader_guc, 68)	!= 68) {
				printf ("SaveMatB1: The file could not be written : %s\n", OutFileName);
				close (binfile_fd2);
				exit(1);
			}
		}
		if (write(binfile_fd2, Material_Volume, sizeof(T)*WHD)	!=sizeof(T)*WHD) {
			printf ("SaveMatB2: The file could not be written : %s\n", OutFileName);
			close (binfile_fd2);
			exit(1);
		}
		close (binfile_fd2);
		if (chmod(OutFileName, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH) < 0) {
			printf ("chmod was not worked to file %s\n", OutFileName);
			exit(1);
		}
/*		
		if (inDepth_gi==1) {
			char	SystemCommand[500];
			// Change image format
			SliceMinf = 5500.0;
			sprintf (SystemCommand, "imgcopy -m %f -M %f \"%s#raw%%size=%d,%d%%colormodel=luminance%%type=%s\" %s.tif",
						SliceMinf, SliceMaxf, OutFileName, inWidth_gi, inHeight_gi, TypeName, OutFileName);
			printf ("%s\n", SystemCommand);
			system(SystemCommand);

			// Remove .raw file
			sprintf (SystemCommand, "rm %s", OutFileName);
			printf ("%s\n", SystemCommand);
			system(SystemCommand);
		}
*/
	}
	delete [] Material_Volume;
}


template<class T>
void SaveMaterialVolumeWithHistogram(T *data, float *Material_Prob, float Minf, float Maxf, int* Histo, float HistoF, 
										int WindowSize, int NumMaterials, char *Name)
{

	char	OutFileName[200];
	int     binfile_fd2;
	int		k, m, WHD, DataValueinHistogram;
	float	SliceMinf, SliceMaxf;
	double	Probability;


	WHD = inWidth_gi*inHeight_gi*inDepth_gi;
	T *Material_VolumeH = new T [WHD];
	
	for (m=0; m<NumMaterials; m++) {

		SliceMinf = 99999;
		SliceMaxf = -99999;
		for (k=0; k<WHD; k++) {

			DataValueinHistogram = (int)(((double)data[k]-Minf)*HistoF);
			Probability = Material_Prob[DataValueinHistogram*NumMaterials + m];

			if (Probability>0.01) {
				Material_VolumeH[k] = (T)(Probability*Maxf);
			}
			else Material_VolumeH[k] = (T)(Maxf*0.01);
			if (SliceMinf > (float)Material_VolumeH[k]) SliceMinf = (float)Material_VolumeH[k];
			if (SliceMaxf < (float)Material_VolumeH[k]) SliceMaxf = (float)Material_VolumeH[k];
		}

		if (RawivHeader_guc!=NULL) {
			sprintf (OutFileName, "%s%02d-W%02d-Mat%02d%s.rawiv", TargetName_gc, m, WindowSize, NumMaterials, Name);
		}
		else {
			sprintf (OutFileName, "%s%02d-W%02d-Mat%02d%s.raw", TargetName_gc, m, WindowSize, NumMaterials, Name);
		}
		printf ("Output File = %s\n", OutFileName); fflush (stdout);

		if ((binfile_fd2 = open (OutFileName, O_CREAT | O_WRONLY | O_TRUNC)) < 0) {
			printf ("could not open %s\n", OutFileName);
			exit(1);
		}
		if (RawivHeader_guc!=NULL) {
			if (write(binfile_fd2, RawivHeader_guc, 68)	!= 68) {
				printf ("SaveMatVH1: The file could not be written : %s\n", OutFileName);
				close (binfile_fd2);
				exit(1);
			}
		}
		if (write(binfile_fd2, Material_VolumeH, sizeof(T)*WHD)	!=sizeof(T)*WHD) {
			printf ("SaveMatVH1: The file could not be written : %s\n", OutFileName);
			close (binfile_fd2);
			exit(1);
		}
		close (binfile_fd2);
		if (chmod(OutFileName, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH) < 0) {
			printf ("chmod was not worked to file %s\n", OutFileName);
			exit(1);
		}
/*
		if (inDepth_gi==1) {
			char	SystemCommand[500];
			// Change image format
			SliceMinf = 5500.0;
			sprintf (SystemCommand, "imgcopy -m %f -M %f \"%s#raw%%size=%d,%d%%colormodel=luminance%%type=%s\" %s.tif",
						SliceMinf, SliceMaxf, OutFileName, inWidth_gi, inHeight_gi, TypeName, OutFileName);
			printf ("%s\n", SystemCommand);
			system(SystemCommand);

			// Remove .raw file
			sprintf (SystemCommand, "rm %s", OutFileName);
			printf ("%s\n", SystemCommand);
			system(SystemCommand);
		}
*/
	}
	delete [] Material_VolumeH;

}

template<class T>
void SaveMaterialVolumeRawVWithHistogram(T *data, float *Material_Prob, float Minf, float Maxf, int* Histo, float HistoF, 
										int WindowSize, int NumMaterials, char *Name)
{
/*
Header:
Offset				Size				Type				Description
--------------------------------------------------------------------------------
0					4				uint				Magic = 0xBAADBEEF
4					4x3				uint				XYZ Dimension
16					4				uint				# of Timesteps
20					4				uint				# of Variables
24					4x4				float				min X,Y,Z,T
40					4x4				float				max X,Y,Z,T
56					1				uchar				Variable Type 1
57					1x64			char				Variable Name 1
.
.
.
XXXX				1				uchar				Variable Type n
XXXX				1x64			char				Variable Name n
Data Begins

- All data including the header is big endian
- Fixed size 121 byte header for single variable datasets
- Variable names are NULL terminated
- Variable types are:
	- 1 for unsigned char (1 byte)
	- 2 for unsigned short (2 bytes)
	- 3 for unsigned int/long (4 bytes)
	- 4 for float (4 bytes)
	- 5 for double (8 bytes)

*/

	char	OutFileName[200];
	int     binfile_fd2;
	int		i, k, m, WHD_i, DataValueinHistogram;
	float	SliceMinf, SliceMaxf;
	double	Probability;


	WHD_i = inWidth_gi*inHeight_gi*inDepth_gi;

	sprintf (OutFileName, "%sMat%02d.rawv", Name, NumMaterials);
	printf ("Output File = %s\n", OutFileName); fflush (stdout);
	if ((binfile_fd2 = open (OutFileName, O_CREAT | O_WRONLY | O_TRUNC)) < 0) {
		printf ("could not open %s\n", OutFileName);
		exit(1);
	}
	

	// RawV Header Description
	unsigned int	MagicNum = 0xBAADBEEF;
	unsigned int	DimXYZ[3];
	unsigned int	NumTimeStep;
	unsigned int	NumVariables = NumMaterials;
	float			MinXYZT[4];
	float			MaxXYZT[4];
	float			*Tempf;


	DimXYZ[0] = inWidth_gi;
	DimXYZ[1] = inHeight_gi;
	DimXYZ[2] = inDepth_gi;
	NumTimeStep = 1;
	for (i=0; i<4; i++) MinXYZT[i] = 0.0;

	if (RawivHeader_guc!=NULL) {
		Tempf = (float *)&RawivHeader_guc[56];
		MaxXYZT[0] = (float)*Tempf*DimXYZ[0];
		Tempf = (float *)&RawivHeader_guc[60];
		MaxXYZT[1] = (float)*Tempf*DimXYZ[1];
		Tempf = (float *)&RawivHeader_guc[64];
		MaxXYZT[2] = (float)*Tempf*DimXYZ[2];
		MaxXYZT[3] = (float)1.0;
	}
	else {
		MaxXYZT[0] = (float)DimXYZ[0];
		MaxXYZT[1] = (float)DimXYZ[1];
		MaxXYZT[2] = (float)DimXYZ[2];
		MaxXYZT[3] = (float)1.0;
	}

	int		HeaderSize = 0;
	HeaderSize += sizeof(MagicNum);
	HeaderSize += sizeof(DimXYZ[0])*3;
	HeaderSize += sizeof(NumTimeStep);
	HeaderSize += sizeof(NumMaterials);
	HeaderSize += sizeof(MinXYZT[0])*4;
	HeaderSize += sizeof(MaxXYZT[0])*4;
	printf ("Header Size = %d\n", HeaderSize);
	fflush (stdout);
	
	if (write(binfile_fd2, &MagicNum, sizeof(MagicNum))!= sizeof(MagicNum)) {
		printf ("Save1: The file could not be written : %s\n", OutFileName);
		close (binfile_fd2);
		exit(1);
	}
	if (write(binfile_fd2, DimXYZ, sizeof(DimXYZ[0])*3)	!= sizeof(DimXYZ[0])*3) {
		printf ("Save2: The file could not be written : %s\n", OutFileName);
		close (binfile_fd2);
		exit(1);
	}
	if (write(binfile_fd2, &NumTimeStep, sizeof(NumTimeStep))!= sizeof(NumTimeStep)) {
		printf ("Save3: The file could not be written : %s\n", OutFileName);
		close (binfile_fd2);
		exit(1);
	}
	if (write(binfile_fd2, &NumVariables, sizeof(NumVariables))!= sizeof(NumVariables)) {
		printf ("Save4: The file could not be written : %s\n", OutFileName);
		close (binfile_fd2);
		exit(1);
	}
	if (write(binfile_fd2, MinXYZT, sizeof(MinXYZT[0])*4)	!= sizeof(MinXYZT[0])*4) {
		printf ("Save5: The file could not be written : %s\n", OutFileName);
		close (binfile_fd2);
		exit(1);
	}
	if (write(binfile_fd2, MaxXYZT, sizeof(MaxXYZT[0])*4)	!= sizeof(MaxXYZT[0])*4) {
		printf ("Save6: The file could not be written : %s\n", OutFileName);
		close (binfile_fd2);
		exit(1);
	}


	T *Material_VolumeH = new T [WHD_i];
	unsigned char	VariableType1 = 1; // 1 = unsigned char
	char			VariableName[64];
	
	for (m=0; m<NumVariables; m++) {
		sprintf (VariableName, "Material Number %2d", m+1);
		if (write(binfile_fd2, &VariableType1, sizeof(VariableType1))!= sizeof(VariableType1)) {
			printf ("SaveMat7: The file could not be written : %s\n", OutFileName);
			close (binfile_fd2);
			exit(1);
		}
		if (write(binfile_fd2, VariableName, sizeof(VariableName[0])*64)!= sizeof(VariableName[0])*64) {
			printf ("SaveMat8: The file could not be written : %s\n", OutFileName);
			close (binfile_fd2);
			exit(1);
		}
	}
	
	
	for (m=0; m<NumVariables; m++) {
		SliceMinf = 99999;
		SliceMaxf = -99999;
		for (k=0; k<WHD_i; k++) {

			DataValueinHistogram = (int)(((double)data[k]-Minf)*HistoF);
			Probability = Material_Prob[DataValueinHistogram*NumMaterials + m];

			if (Probability>0.01) {
				Material_VolumeH[k] = (T)(Probability*Maxf);
			}
			else Material_VolumeH[k] = (T)(Maxf*0.01);
			if (SliceMinf > (float)Material_VolumeH[k]) SliceMinf = (float)Material_VolumeH[k];
			if (SliceMaxf < (float)Material_VolumeH[k]) SliceMaxf = (float)Material_VolumeH[k];
		}

		// Variables
		if (write(binfile_fd2, Material_VolumeH, sizeof(T)*WHD_i)	!=sizeof(T)*WHD_i) {
			printf ("SaveMat9: The file could not be written : %s\n", OutFileName);
			close (binfile_fd2);
			exit(1);
		}
	}

	close (binfile_fd2);
	if (chmod(OutFileName, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH) < 0) {
		printf ("chmod was not worked to file %s\n", OutFileName);
		exit(1);
	}

	delete [] Material_VolumeH;

}


template<class T>
void SaveVolumeRawV(T *data, unsigned char *GradMag, unsigned char *DistVolume, char *Name)
{
/*
Header:
Offset				Size				Type				Description
--------------------------------------------------------------------------------
0					4				uint				Magic = 0xBAADBEEF
4					4x3				uint				XYZ Dimension
16					4				uint				# of Timesteps
20					4				uint				# of Variables
24					4x4				float				min X,Y,Z,T
40					4x4				float				max X,Y,Z,T
56					1				uchar				Variable Type 1
57					1x64			char				Variable Name 1
.
.
.
XXXX				1				uchar				Variable Type n
XXXX				1x64			char				Variable Name n
Data Begins

- All data including the header is big endian
- Fixed size 121 byte header for single variable datasets
- Variable names are NULL terminated
- Variable types are:
	- 1 for unsigned char (1 byte)
	- 2 for unsigned short (2 bytes)
	- 3 for unsigned int/long (4 bytes)
	- 4 for float (4 bytes)
	- 5 for double (8 bytes)

*/


	char	OutFileName[200];
	int     binfile_fd2;
	int		i, WHD_i;


	WHD_i = inWidth_gi*inHeight_gi*inDepth_gi;

	sprintf (OutFileName, "%s.rawv", Name);
	printf ("Output File = %s\n", OutFileName); fflush (stdout);
	if ((binfile_fd2 = open (OutFileName, O_CREAT | O_WRONLY | O_TRUNC)) < 0) {
		printf ("could not open %s\n", OutFileName);
		exit(1);
	}
	

	// RawV Header Description
	unsigned int	MagicNum = 0xBAADBEEF;
	unsigned int	DimXYZ[3];
	unsigned int	NumTimeStep;
	unsigned int	NumVariables;
	float			MinXYZT[4];
	float			MaxXYZT[4];
	float			*Tempf;


	DimXYZ[0] = inWidth_gi;
	DimXYZ[1] = inHeight_gi;
	DimXYZ[2] = inDepth_gi;
	NumTimeStep = 1;
	NumVariables = 3;
	for (i=0; i<4; i++) MinXYZT[i] = 0.0;

	if (RawivHeader_guc!=NULL) {
		Tempf = (float *)&RawivHeader_guc[56];
		MaxXYZT[0] = (float)*Tempf*DimXYZ[0];
		Tempf = (float *)&RawivHeader_guc[60];
		MaxXYZT[1] = (float)*Tempf*DimXYZ[1];
		Tempf = (float *)&RawivHeader_guc[64];
		MaxXYZT[2] = (float)*Tempf*DimXYZ[2];
		MaxXYZT[3] = (float)1.0;
	}
	else {
		MaxXYZT[0] = (float)DimXYZ[0];
		MaxXYZT[1] = (float)DimXYZ[1];
		MaxXYZT[2] = (float)DimXYZ[2];
		MaxXYZT[3] = (float)1.0;
	}

	int		HeaderSize = 0;
	HeaderSize += sizeof(MagicNum);
	HeaderSize += sizeof(DimXYZ[0])*3;
	HeaderSize += sizeof(NumTimeStep);
	HeaderSize += sizeof(NumVariables);
	HeaderSize += sizeof(MinXYZT[0])*4;
	HeaderSize += sizeof(MaxXYZT[0])*4;
	printf ("Header Size = %d\n", HeaderSize);
	fflush (stdout);
	
	if (write(binfile_fd2, &MagicNum, sizeof(MagicNum))!= sizeof(MagicNum)) {
		printf ("Save1: The file could not be written : %s\n", OutFileName);
		close (binfile_fd2);
		exit(1);
	}
	if (write(binfile_fd2, DimXYZ, sizeof(DimXYZ[0])*3)	!= sizeof(DimXYZ[0])*3) {
		printf ("Save2: The file could not be written : %s\n", OutFileName);
		close (binfile_fd2);
		exit(1);
	}
	if (write(binfile_fd2, &NumTimeStep, sizeof(NumTimeStep))!= sizeof(NumTimeStep)) {
		printf ("Save3: The file could not be written : %s\n", OutFileName);
		close (binfile_fd2);
		exit(1);
	}
	if (write(binfile_fd2, &NumVariables, sizeof(NumVariables))!= sizeof(NumVariables)) {
		printf ("Save4: The file could not be written : %s\n", OutFileName);
		close (binfile_fd2);
		exit(1);
	}
	if (write(binfile_fd2, MinXYZT, sizeof(MinXYZT[0])*4)	!= sizeof(MinXYZT[0])*4) {
		printf ("Save5: The file could not be written : %s\n", OutFileName);
		close (binfile_fd2);
		exit(1);
	}
	if (write(binfile_fd2, MaxXYZT, sizeof(MaxXYZT[0])*4)	!= sizeof(MaxXYZT[0])*4) {
		printf ("Save6: The file could not be written : %s\n", OutFileName);
		close (binfile_fd2);
		exit(1);
	}


	// Variable 1
	unsigned char	VariableType1 = (unsigned char)sizeof(T);
	char			VariableName1[64]="Data Value";
	if (write(binfile_fd2, &VariableType1, 1) != 1) {
		printf ("Save7: The file could not be written : %s\n", OutFileName);
		close (binfile_fd2);
		exit(1);
	}
	if (write(binfile_fd2, VariableName1, 64) != 64) {
		printf ("Save8: The file could not be written : %s\n", OutFileName);
		close (binfile_fd2);
		exit(1);
	}

	// Variable 2
	unsigned char	VariableType2 = 1;
	char			VariableName2[64]="Gradient Magnitude at the Nearest Boundary";
	if (write(binfile_fd2, &VariableType2, 1) != 1) {
		printf ("Save10: The file could not be written : %s\n", OutFileName);
		close (binfile_fd2);
		exit(1);
	}
	if (write(binfile_fd2, VariableName2, 64)!= 64) {
		printf ("Save11: The file could not be written : %s\n", OutFileName);
		close (binfile_fd2);
		exit(1);
	}

	// Variable 3
	unsigned char	VariableType3 = 1;
	char			VariableName3[64]="Distance to the Nearest Boundary";
	if (write(binfile_fd2, &VariableType3, 1) != 1) {
		printf ("Save13: The file could not be written : %s\n", OutFileName);
		close (binfile_fd2);
		exit(1);
	}
	if (write(binfile_fd2, VariableName3, 64)!= 64) {
		printf ("Save14: The file could not be written : %s\n", OutFileName);
		close (binfile_fd2);
		exit(1);
	}

	
	if (write(binfile_fd2, data, (int)sizeof(T)*WHD_i) != (int)sizeof(T)*WHD_i) {
		printf ("sizeof(T) = %d\n", (int)sizeof(T));
		printf ("Save9: Error! The file could not be written : %s\n", OutFileName);
		fflush (stdout);
		close (binfile_fd2);
		exit(1);
	}
	if (write(binfile_fd2, GradMag, WHD_i)	!=WHD_i) {
		printf ("Save12: The file could not be written : %s\n", OutFileName);
		close (binfile_fd2);
		exit(1);
	}
	if (write(binfile_fd2, DistVolume, WHD_i)	!=WHD_i) {
		printf ("Save15: The file could not be written : %s\n", OutFileName);
		close (binfile_fd2);
		exit(1);
	}

	close (binfile_fd2);
	if (chmod(OutFileName, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH) < 0) {
		printf ("chmod was not worked to file %s\n", OutFileName);
		exit(1);
	}

}


template<class T> 
void SaveMaterialVolume(float *Material_Prob, T *data, float Minf, float Maxf, int WindowSize, 
							int NumMaterials, char *Name)
{
#ifdef		SAVE_MATERIAL_VOLUME_RAWIV
	char	OutFileName[200];
	int     binfile_fd2;
	int		k, m, WHD;
	float	SliceMinf, SliceMaxf;


	WHD = inWidth_gi*inHeight_gi*inDepth_gi;
	T *Material_Volume = new T [WHD];
	
	for (m=0; m<NumMaterials; m++) {

		SliceMinf = 99999;
		SliceMaxf = -99999;
		for (k=0; k<WHD; k++) {
			if (Material_Prob[m*WHD + k]>0.01) { // 1%
				Material_Volume[k] = (T)(Maxf*Material_Prob[m*WHD + k]);
			}
			else Material_Volume[k] = (T)(Maxf*0.01);
			if (SliceMinf > (float)Material_Volume[k]) SliceMinf = (float)Material_Volume[k];
			if (SliceMaxf < (float)Material_Volume[k]) SliceMaxf = (float)Material_Volume[k];
		}

		if (RawivHeader_guc!=NULL) {
			sprintf (OutFileName, "%s%02d-W%02d-Mat%02d%s.rawiv", TargetName_gc, m, WindowSize, NumMaterials, Name);
		}
		else {
			sprintf (OutFileName, "%s%02d-W%02d-Mat%02d%s.raw", TargetName_gc, m, WindowSize, NumMaterials, Name);
		}
		printf ("Output File = %s\n", OutFileName); fflush (stdout);

		if ((binfile_fd2 = open (OutFileName, O_CREAT | O_WRONLY | O_TRUNC)) < 0) {
			printf ("could not open %s\n", OutFileName);
			exit(1);
		}
		if (RawivHeader_guc!=NULL) {
			if (write(binfile_fd2, RawivHeader_guc, 68)	!= 68) {
				printf ("SaveMatV1: The file could not be written : %s\n", OutFileName);
				close (binfile_fd2);
				exit(1);
			}
		}
		if (write(binfile_fd2, Material_Volume, sizeof(T)*WHD)	!=sizeof(T)*WHD) {
			printf ("SaveMatV2: The file could not be written : %s\n", OutFileName);
			close (binfile_fd2);
			exit(1);
		}
		close (binfile_fd2);
		if (chmod(OutFileName, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH) < 0) {
			printf ("chmod was not worked to file %s\n", OutFileName);
			exit(1);
		}
/*		
		if (inDepth_gi==1) {
			char	SystemCommand[500];
			// Change image format
			SliceMinf = 5500.0;
			sprintf (SystemCommand, "imgcopy -m %f -M %f \"%s#raw%%size=%d,%d%%colormodel=luminance%%type=%s\" %s.tif",
						SliceMinf, SliceMaxf, OutFileName, inWidth_gi, inHeight_gi, TypeName, OutFileName);
			printf ("%s\n", SystemCommand);
			system(SystemCommand);

			// Remove .raw file
			sprintf (SystemCommand, "rm %s", OutFileName);
			printf ("%s\n", SystemCommand);
			system(SystemCommand);
		}
*/
	}
	delete [] Material_Volume;
#endif
}



float *Calculate_Gradient_Magnitude_From_Vectors(float *Gradient_Vectors, double& Min, double& Max)
{
	long int	i, j, k, WHD, WtimesH, loc[3];
	float		*Gradient_Magnitude, Dx, Dy, Dz;
	double		Tempd;


	printf ("Calculate Gradient Magnitude from Vectors ...\n"); fflush (stdout);
	
	WtimesH = inWidth_gi*inHeight_gi;
	WHD = inWidth_gi*inHeight_gi*inDepth_gi;
	Gradient_Magnitude = new float [WHD];

	if (inDepth_gi==1) {
		for (j=0; j<inHeight_gi; j++) {
			for (k=0; k<inWidth_gi; k++) {
				Dx = Gradient_Vectors[j*inWidth_gi*3 + k*3 + 0];
				Dy = Gradient_Vectors[j*inWidth_gi*3 + k*3 + 1];

				Tempd = sqrt((double)Dx*Dx + Dy*Dy);
				Gradient_Magnitude[j*inWidth_gi + k] = (float)Tempd;
			}
		}
	}
	else {
		for (i=0; i<inDepth_gi; i++) {
			for (j=0; j<inHeight_gi; j++) {
				for (k=0; k<inWidth_gi; k++) {
					loc[0] = i*WtimesH*3 + j*inWidth_gi*3 + k*3;
					Dx = Gradient_Vectors[loc[0] + 0];
					Dy = Gradient_Vectors[loc[0] + 1];
					Dz = Gradient_Vectors[loc[0] + 2];

					Tempd = sqrt((double)Dx*Dx + Dy*Dy + Dz*Dz);
					loc[1] = i*WtimesH + j*inWidth_gi + k;
					Gradient_Magnitude[loc[1]] = (float)Tempd;
				}
			}
		}
	}
	
	
	Min = DBL_MAX;
	Max = -DBL_MAX;
	for (i=0; i<WHD; i++) {
		if ((double)Gradient_Magnitude[i]<Min) Min = (double)Gradient_Magnitude[i];
		if ((double)Gradient_Magnitude[i]>Max) Max = (double)Gradient_Magnitude[i];
	}
	
	return Gradient_Magnitude;
}


template<class T>
float *Calculate_Gradient_Magnitude(T *data, double& Min, double& Max)
{
	int     i, j, k, WHD, WtimesH;
	float	*Gradient_Magnitude, Dx, Dy, Dz;
	double	Tempd;


	WtimesH = inWidth_gi*inHeight_gi;
	WHD = inWidth_gi*inHeight_gi*inDepth_gi;
	Gradient_Magnitude = new float [WHD];

	if (inDepth_gi==1) {
		for (j=0; j<inHeight_gi; j++) {
			for (k=0; k<inWidth_gi; k++) {
				if (k==0) Dx = (float)(data[j*inWidth_gi + k+1] - 0);
				else if (k==inWidth_gi-1) Dx = (float)(0 - data[j*inWidth_gi + k-1]);
				else Dx = (float)(data[j*inWidth_gi + k+1] - data[j*inWidth_gi + k-1]);

				if (j==0) Dy = (float)(data[(j+1)*inWidth_gi + k] - 0);
				else if (j==inHeight_gi-1) Dy = (float)(0 - data[(j-1)*inWidth_gi + k]);
				else Dy = (float)(data[(j+1)*inWidth_gi + k] - data[(j-1)*inWidth_gi + k]);

				Tempd = (double)Dx*Dx + Dy*Dy;
				Tempd = sqrt(Tempd);
				Gradient_Magnitude[j*inWidth_gi + k] = (float)Tempd;
			}
		}
	}
	else {
		for (i=0; i<inDepth_gi; i++) {
			for (j=0; j<inHeight_gi; j++) {
				for (k=0; k<inWidth_gi; k++) {
					if (k==0) Dx = (float)(data[i*WtimesH + j*inWidth_gi + k+1] - 0);
					else if (k==inWidth_gi-1) Dx = (float)(0 - data[i*WtimesH + j*inWidth_gi + k-1]);
					else Dx = (float)(data[i*WtimesH + j*inWidth_gi + k+1] - data[i*WtimesH + j*inWidth_gi + k-1]);

					if (j==0) Dy = (float)(data[i*WtimesH + (j+1)*inWidth_gi + k] - 0);
					else if (j==inHeight_gi-1) Dy = (float)(0 - data[i*WtimesH + (j-1)*inWidth_gi + k]);
					else Dy = (float)(data[i*WtimesH + (j+1)*inWidth_gi + k] - data[i*WtimesH + (j-1)*inWidth_gi + k]);

					if (i==0) Dz = (float)(data[(i+1)*WtimesH + j*inWidth_gi + k] - 0);
					else if (i==inDepth_gi-1) Dz = (float)(0 - data[(i-1)*WtimesH + j*inWidth_gi + k]);
					else Dz = (float)(data[(i+1)*WtimesH + j*inWidth_gi + k] - data[(i-1)*WtimesH + j*inWidth_gi + k]);

					Tempd = (double)Dx*Dx + Dy*Dy + Dz*Dz;
					Tempd = sqrt(Tempd);

					Gradient_Magnitude[i*WtimesH + j*inWidth_gi + k] = (float)Tempd;
				}
			}
		}
	}
	
	
	Min = DBL_MAX;
	Max = -DBL_MAX;
	for (i=0; i<WHD; i++) {
		if ((double)Gradient_Magnitude[i]<Min) Min = (double)Gradient_Magnitude[i];
		if ((double)Gradient_Magnitude[i]>Max) Max = (double)Gradient_Magnitude[i];
	}
	
	return Gradient_Magnitude;
}

template<class T>
float *MLCA_Smoothing(T *Data_in, int NumRepeatition)
{
	int				l, n;
	long int		i, j, k, loc[8], WHD, WtimesH;
	double			Tempd;
	float			*Avg_data_f;
	

	printf ("MLCA Smoothing ... \n"); fflush (stdout);
	WtimesH = (long int)inWidth_gi*inHeight_gi;
	WHD = (long int)inWidth_gi*inHeight_gi*inDepth_gi;
	
	Avg_data_f = new float [WHD];
	float *data_f = new float [WHD];
	for (i=0; i<WHD; i++) data_f[i] = Data_in[i];

	
	for (l=0; l<NumRepeatition; l++) {

		printf ("Num Repeats = %d \n", l); fflush (stdout);
	
		for (k=0; k<inDepth_gi-1; k++) {
			for (j=0; j<inHeight_gi-1; j++) {
				for (i=0; i<inWidth_gi-1; i++) {

					loc[0] = k*WtimesH + j*inWidth_gi + i;
					loc[1] = k*WtimesH + j*inWidth_gi + i+1;
					loc[2] = k*WtimesH + (j+1)*inWidth_gi + i;
					loc[3] = k*WtimesH + (j+1)*inWidth_gi + i+1;

					loc[4] = (k+1)*WtimesH + j*inWidth_gi + i;
					loc[5] = (k+1)*WtimesH + j*inWidth_gi + i+1;
					loc[6] = (k+1)*WtimesH + (j+1)*inWidth_gi + i;
					loc[7] = (k+1)*WtimesH + (j+1)*inWidth_gi + i+1;

					Avg_data_f[loc[0]]=(float)0.0;
					for (n=0; n<8; n++) Avg_data_f[loc[0]]+=data_f[loc[n]];
					Avg_data_f[loc[0]]/=(float)8.0;
				}
			}
		}
		for (k=1; k<inDepth_gi-1; k++) {
			for (j=1; j<inHeight_gi-1; j++) {
				for (i=1; i<inWidth_gi-1; i++) {
					loc[0] = (k-1)*WtimesH + (j-1)*inWidth_gi + i-1;
					loc[1] = (k-1)*WtimesH + (j-1)*inWidth_gi + i;
					loc[2] = (k-1)*WtimesH + j*inWidth_gi + i-1;
					loc[3] = (k-1)*WtimesH + j*inWidth_gi + i;

					loc[4] = k*WtimesH + (j-1)*inWidth_gi + i-1;
					loc[5] = k*WtimesH + (j-1)*inWidth_gi + i;
					loc[6] = k*WtimesH + j*inWidth_gi + i-1;
					loc[7] = k*WtimesH + j*inWidth_gi + i;

					Tempd=(double)0.0;
					for (n=0; n<8; n++) Tempd+=(double)Avg_data_f[loc[n]];
					Tempd/=(double)8.0;
					data_f[loc[7]]=(float)Tempd;
				}
			}
		}
		
	}
	
	delete [] Avg_data_f;
	
	return data_f;
}	


template<class T>
float *Calculate_Gradient_Vectors(T *data_in)
{
	int     	i, j, k;
	long int	loc[3], WHD, WtimesH;
	float		*Gradient_Vectors, Dx, Dy, Dz;
	float		*data;
	
	cout << "Start the function, Calculate Gradient Vectors" << endl;

	WtimesH = (long int)inWidth_gi*inHeight_gi;
	WHD = (long int)inWidth_gi*inHeight_gi*inDepth_gi;

#ifdef	MLCA_SMOOTHING
	int		MLCAData_fd1, MLCAData_fd2;
	char 	MLCA_FileName[512];
	int		NumRepeats = 3;
	
	cout << "Apply MLCA Smoothing for the Input Data" << endl;
	sprintf (MLCA_FileName, "%s_MLCAR%d.%s", TargetName_gc, NumRepeats, "rawiv");

	if ((MLCAData_fd1 = open (MLCA_FileName, O_RDONLY)) < 0) {
		cout << MLCA_FileName << " does not exist" << endl;
		cout << "Create a New One: " <<  MLCA_FileName << endl;
		data = MLCA_Smoothing(data_in, NumRepeats);
		
		if ((MLCAData_fd2 = open (MLCA_FileName, O_CREAT | O_WRONLY)) < 0) {
			cout << "could not open " << MLCA_FileName << endl; exit(1);
		}
		if (write(MLCAData_fd2, RawivHeader_guc, 68)!=68) {
			cout << "The MLCA file could not be written " << MLCA_FileName << endl;
			close (MLCAData_fd2); exit(1);
		}
		if (write(MLCAData_fd2, data, sizeof(float)*WHD)!=sizeof(float)*WHD) {
			cout << "The Diffusion file could not be written " << MLCA_FileName << endl;
			close (MLCAData_fd2); exit(1);
		}
		if (chmod(MLCA_FileName, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH) < 0) {
			cout << "chmod was not worked to MLCA file " << MLCA_FileName << endl; exit(1);
		}
	}
	else {
		cout << "The file exists: " <<  MLCA_FileName << endl;
		unsigned char	TempHeader[68];
		if (read(MLCAData_fd1, TempHeader, 68) != 68) {
			cout << "The MLCA file could not be read " << MLCA_FileName << endl;
			close (MLCAData_fd1);
			exit(1);
		}
		data = new float [WHD];
		if (read(MLCAData_fd1, data, sizeof(float)*WHD) != sizeof(float)*WHD) {
			cout << "The MLCA file could not be read " << MLCA_FileName << endl;
			close (MLCAData_fd1);
			exit(1);
		}
	}
#else
	data = new float [WHD];
	for (i=0; i<WHD; i++) data[i] = (float)data_in[i];
#endif
	
	
	Gradient_Vectors = NULL;
	Gradient_Vectors = new float [WHD*3];
	if (Gradient_Vectors==NULL) cout << "Out of memory (Gradient_Vectors)" << endl;

	if (inDepth_gi==1) {
		for (j=0; j<inHeight_gi; j++) {
			for (k=0; k<inWidth_gi; k++) {
				if (k==0) Dx = (float)(data[j*inWidth_gi + k+1] - 0);
				else if (k==inWidth_gi-1) Dx = (float)(0 - data[j*inWidth_gi + k-1]);
				else Dx = (float)(data[j*inWidth_gi + k+1] - data[j*inWidth_gi + k-1]);

				if (j==0) Dy = (float)(data[(j+1)*inWidth_gi + k] - 0);
				else if (j==inHeight_gi-1) Dy = (float)(0 - data[(j-1)*inWidth_gi + k]);
				else Dy = (float)(data[(j+1)*inWidth_gi + k] - data[(j-1)*inWidth_gi + k]);

				Gradient_Vectors[j*inWidth_gi*3 + k*3 + 0] = (float)Dx/2.0;
				Gradient_Vectors[j*inWidth_gi*3 + k*3 + 1] = (float)Dy/2.0;
				Gradient_Vectors[j*inWidth_gi*3 + k*3 + 2] = (float)0.0;
			}
		}
	}
	else {
		for (i=0; i<inDepth_gi; i++) {
			for (j=0; j<inHeight_gi; j++) {
				for (k=0; k<inWidth_gi; k++) {
					loc[0] = i*WtimesH + j*inWidth_gi + k+1;
					loc[1] = i*WtimesH + j*inWidth_gi + k-1;
					if (k==0) Dx = (float)(data[loc[0]] - 0);
					else if (k==inWidth_gi-1) Dx = (float)(0 - data[loc[1]]);
					else Dx = (float)(data[loc[0]] - data[loc[1]]);

					loc[0] = i*WtimesH + (j+1)*inWidth_gi + k;
					loc[1] = i*WtimesH + (j-1)*inWidth_gi + k;
					if (j==0) Dy = (float)(data[loc[0]] - 0);
					else if (j==inHeight_gi-1) Dy = (float)(0 - data[loc[1]]);
					else Dy = (float)(data[loc[0]] - data[loc[1]]);

					loc[0] = (i+1)*WtimesH + j*inWidth_gi + k;
					loc[1] = (i-1)*WtimesH + j*inWidth_gi + k;
					if (i==0) Dz = (float)(data[loc[0]] - 0);
					else if (i==inDepth_gi-1) Dz = (float)(0 - data[loc[1]]);
					else Dz = (float)(data[loc[0]] - data[loc[1]]);
					
					loc[2] = i*WtimesH*3 + j*inWidth_gi*3 + k*3;
					Gradient_Vectors[loc[2] + 0] = (float)Dx*0.5;
					Gradient_Vectors[loc[2] + 1] = (float)Dy*0.5;
					Gradient_Vectors[loc[2] + 2] = (float)Dz*0.5;
				}
			}
		}
	}

	delete [] data;

	return Gradient_Vectors;
}

int	Index(int X, int Y, int Z)
{
	if (X<0 || Y<0 || Z<0 || X>=inWidth_gi || Y>=inHeight_gi || Z>=inDepth_gi) return 0;
	else return (Z*inWidth_gi*inHeight_gi + Y*inWidth_gi + X);
}

long int Index(long int X, long int Y, long int Z)
{
	if (X<0 || Y<0 || Z<0 || X>=inWidth_gi || Y>=inHeight_gi || Z>=inDepth_gi) return 0;
	else return (Z*inWidth_gi*inHeight_gi + Y*inWidth_gi + X);
}

int	Idx_Diff(int X, int Y, int Z)
{
	if (X<0) X = 0;
	if (Y<0) Y = 0;
	if (Z<0) Z = 0;
	if (X>=inWidth_gi) X = inWidth_gi - 1;
	if (Y>=inHeight_gi) Y = inHeight_gi - 1;
	if (Z>=inDepth_gi) Z = inDepth_gi - 1;
	return (Z*inWidth_gi*inHeight_gi + Y*inWidth_gi + X);
}


// Anisotropic Diffusion for 3D vectors
void Anisotropic_Vector_Diffusion_3D(float *Vectors, int NumIterations)
{
	int		WHD_mi, Width_mi, Height_mi, Depth_mi;
	int		i, j, k, CLoc, Iterations_i;
	int		LLoc, RLoc, ULoc, DLoc, BLoc, FLoc;
	float	Front_f, Back_f, Right_f, Left_f, Up_f, Down_f, Tempf;
	float	Kapa_f = 3.0, CVecLength_f, NLength_f;
	float	CVec_f[3];


	Width_mi = inWidth_gi;
	Height_mi = inHeight_gi;
	Depth_mi = inDepth_gi;
	WHD_mi = Width_mi*Height_mi*Depth_mi;
	float	*u_f = new float [WHD_mi];
	float	*v_f = new float [WHD_mi];
	float	*w_f = new float [WHD_mi];
	
	float	*Tempu_f = new float [WHD_mi];
	float	*Tempv_f = new float [WHD_mi];
	float	*Tempw_f = new float [WHD_mi];
	
	
	
	// For the Index function
	Vectors[0] = Vectors[1] = Vectors[2] = 0.0;
	
	for (i=0; i<WHD_mi; i++) {
		u_f[i] = Tempu_f[i] = Vectors[i*3 + 0];
		v_f[i] = Tempv_f[i] = Vectors[i*3 + 1];
		w_f[i] = Tempw_f[i] = Vectors[i*3 + 2];
	}

	for (Iterations_i=0; Iterations_i<NumIterations; Iterations_i++) {

	    printf ("Anisotropic Vector Diffusion3D: Iteration # = %d/", Iterations_i+1); 
		printf ("%d\n", NumIterations); fflush (stdout);
    
		for (k=1; k<Depth_mi-1; k++) {
   		for (j=1; j<Height_mi-1; j++) {
		for (i=1; i<Width_mi-1; i++) {
			CLoc = Index(i,j,k);
			CVec_f[0] = u_f[CLoc];
			CVec_f[1] = v_f[CLoc];
			CVec_f[2] = w_f[CLoc];
			
			CVecLength_f = sqrt(CVec_f[0]*CVec_f[0] + CVec_f[1]*CVec_f[1] +	CVec_f[2]*CVec_f[2]);

			FLoc = Index(i+1,j,k);	// Front
			BLoc = Index(i-1,j,k);	// Back
			LLoc = Index(i,j+1,k);	// Left
			RLoc = Index(i,j-1,k);	// Right
			ULoc = Index(i,j,k+1);	// Up
			DLoc = Index(i,j,k-1);	// Down

			if (fabsf(CVecLength_f) < 1e-5) {
				Tempu_f[CLoc] =(u_f[FLoc]+u_f[BLoc]+u_f[LLoc]+u_f[RLoc]+u_f[ULoc]+u_f[DLoc])/6.0;
				Tempv_f[CLoc] =(v_f[FLoc]+v_f[BLoc]+v_f[LLoc]+v_f[RLoc]+v_f[ULoc]+v_f[DLoc])/6.0;
				Tempw_f[CLoc] =(w_f[FLoc]+w_f[BLoc]+w_f[LLoc]+w_f[RLoc]+w_f[ULoc]+w_f[DLoc])/6.0;
			}
			else {
				// Front
				NLength_f = sqrt(u_f[FLoc]*u_f[FLoc] + v_f[FLoc]*v_f[FLoc] + w_f[FLoc]*w_f[FLoc]);
				if (NLength_f < 1e-5) Front_f = 0.0;
				else Front_f = expf(Kapa_f*((CVec_f[0]*u_f[FLoc] + CVec_f[1]*v_f[FLoc] + CVec_f[2]*w_f[FLoc])/
											(CVecLength_f*NLength_f)-1));

				// Back
				NLength_f = sqrt(u_f[BLoc]*u_f[BLoc] + v_f[BLoc]*v_f[BLoc] + w_f[BLoc]*w_f[BLoc]);
				if (NLength_f < 1e-5) Back_f = 0.0;
				else Back_f = expf(Kapa_f*((CVec_f[0]*u_f[BLoc] + CVec_f[1]*v_f[BLoc] + CVec_f[2]*w_f[BLoc])/
											(CVecLength_f*NLength_f)-1));

				// Left
				NLength_f = sqrt(u_f[LLoc]*u_f[LLoc] + v_f[LLoc]*v_f[LLoc] + w_f[LLoc]*w_f[LLoc]);
				if (NLength_f < 1e-5) Left_f = 0.0;
				else Left_f = expf(Kapa_f*((CVec_f[0]*u_f[LLoc] + CVec_f[1]*v_f[LLoc] + CVec_f[2]*w_f[LLoc])/
											(CVecLength_f*NLength_f)-1));

				// Right
				NLength_f = sqrt(u_f[RLoc]*u_f[RLoc] + v_f[RLoc]*v_f[RLoc] + w_f[RLoc]*w_f[RLoc]);
				if (NLength_f < 1e-5) Right_f = 0.0;
				else Right_f = expf(Kapa_f*((CVec_f[0]*u_f[RLoc] + CVec_f[1]*v_f[RLoc] + CVec_f[2]*w_f[RLoc])/
											(CVecLength_f*NLength_f)-1));

				// Up
				NLength_f = sqrt(u_f[ULoc]*u_f[ULoc] + v_f[ULoc]*v_f[ULoc] + w_f[ULoc]*w_f[ULoc]);
				if (NLength_f < 1e-5) Up_f = 0.0;
				else Up_f = expf(Kapa_f*((CVec_f[0]*u_f[ULoc] + CVec_f[1]*v_f[ULoc] + CVec_f[2]*w_f[ULoc])/
											(CVecLength_f*NLength_f)-1));

				// Down
				NLength_f = sqrt(u_f[DLoc]*u_f[DLoc] + v_f[DLoc]*v_f[DLoc] + w_f[DLoc]*w_f[DLoc]);
				if (NLength_f < 1e-5) Down_f = 0.0;
				else Down_f = expf(Kapa_f*((CVec_f[0]*u_f[DLoc] + CVec_f[1]*v_f[DLoc] + CVec_f[2]*w_f[DLoc])/
											(CVecLength_f*NLength_f)-1));

				Tempf = Front_f + Back_f + Right_f + Left_f + Up_f + Down_f;
				if (fabs(Tempf)  > 1e-4) {
					Front_f /= Tempf;
					Back_f 	/= Tempf;
					Right_f /= Tempf;
					Left_f 	/= Tempf;
					Up_f 	/= Tempf;
					Down_f 	/= Tempf;
				}


				Tempu_f[Index(i,j,k)] = u_f[CLoc] + (
									  Front_f*(	u_f[FLoc] - u_f[CLoc]) +
									  Back_f*(	u_f[BLoc] - u_f[CLoc]) +
									  Left_f*(	u_f[LLoc] - u_f[CLoc]) +
									  Right_f*(	u_f[RLoc] - u_f[CLoc]) + 
									  Up_f*(	u_f[ULoc] - u_f[CLoc]) + 
									  Down_f*(	u_f[DLoc] - u_f[CLoc]))/6.0;

				Tempv_f[Index(i,j,k)] = v_f[Index(i,j,k)] + (
									  Front_f*(	v_f[FLoc] - v_f[CLoc]) +
									  Back_f*(	v_f[BLoc] - v_f[CLoc]) +
									  Left_f*(	v_f[LLoc] - v_f[CLoc]) +
									  Right_f*(	v_f[RLoc] - v_f[CLoc]) + 
									  Up_f*(	v_f[ULoc] - v_f[CLoc]) + 
									  Down_f*(	v_f[DLoc] - v_f[CLoc]))/6.0;

				Tempw_f[Index(i,j,k)] = w_f[Index(i,j,k)] + (
									  Front_f*(	w_f[FLoc] - w_f[CLoc]) +
									  Back_f*(	w_f[BLoc] - w_f[CLoc]) +
									  Left_f*(	w_f[LLoc] - w_f[CLoc]) +
									  Right_f*(	w_f[RLoc] - w_f[CLoc]) + 
									  Up_f*(	w_f[ULoc] - w_f[CLoc]) + 
									  Down_f*(	w_f[DLoc] - w_f[CLoc]))/6.0;
			}
			
		} // i
		} // j
		} // k
    


		for (i=0; i<WHD_mi; i++) {
			u_f[i] = Tempu_f[i];
			v_f[i] = Tempv_f[i];
			w_f[i] = Tempw_f[i];
		}
    
	}
 

	for (i=0; i<WHD_mi; i++) {
		Vectors[i*3 + 0] = u_f[i];
		Vectors[i*3 + 1] = v_f[i];
		Vectors[i*3 + 2] = w_f[i];
	}

	delete [] u_f;
	delete [] v_f;
	delete [] w_f;
	
	delete [] Tempu_f;
	delete [] Tempv_f;
	delete [] Tempw_f;
}


// Anisotropic Diffusion for 3D scalar values
template<class T>
void Anisotropic_Diffusion_3DScalar(T *ScalarValues, int NumIterations)
{
	long int		WHD_mi, Width_mi, Height_mi, Depth_mi;
	long int		i, j, k, CLoc;
	long int		LLoc, RLoc, ULoc, DLoc, BLoc, FLoc;
	int				Iterations_i;
	float	Front_f, Back_f, Right_f, Left_f, Up_f, Down_f;
	float	IDiff_f;


	Width_mi = inWidth_gi;
	Height_mi = inHeight_gi;
	Depth_mi = inDepth_gi;
	WHD_mi = Width_mi*Height_mi*Depth_mi;
	float	*u_f = new float [WHD_mi];
	float	*Tempu_f = new float [WHD_mi];
	
	
	for (i=0; i<WHD_mi; i++) {
		u_f[i] = Tempu_f[i] = (float)ScalarValues[i];
	}

	for (Iterations_i=0; Iterations_i<NumIterations; Iterations_i++) {

	    printf ("Anisotropic Image Diffusion 3D: Iteration # = %d/", Iterations_i+1);
		printf ("%d\n", NumIterations); fflush (stdout);
    
		for (k=1; k<Depth_mi-1; k++) {
   			for (j=1; j<Height_mi-1; j++) {
				for (i=1; i<Width_mi-1; i++) {
					CLoc = Index(i,j,k);

					FLoc = Index(i+1,j,k);	// Front
					BLoc = Index(i-1,j,k);	// Back
					LLoc = Index(i,j+1,k);	// Left
					RLoc = Index(i,j-1,k);	// Right
					ULoc = Index(i,j,k+1);	// Up
					DLoc = Index(i,j,k-1);	// Down

					// Front
					IDiff_f = u_f[FLoc] - u_f[CLoc];
					Front_f = 1.0/(1.0 + IDiff_f*IDiff_f/9.0);

					// Back
					IDiff_f = u_f[BLoc] - u_f[CLoc];
					Back_f = 1.0/(1.0 + IDiff_f*IDiff_f/9.0);

					// Left
					IDiff_f = u_f[LLoc] - u_f[CLoc];
					Left_f = 1.0/(1.0 + IDiff_f*IDiff_f/9.0);

					// Right
					IDiff_f = u_f[RLoc] - u_f[CLoc];
					Right_f = 1.0/(1.0 + IDiff_f*IDiff_f/9.0);

					// Up
					IDiff_f = u_f[ULoc] - u_f[CLoc];
					Up_f = 1.0/(1.0 + IDiff_f*IDiff_f/9.0);

					// Down
					IDiff_f = u_f[DLoc] - u_f[CLoc];
					Down_f = 1.0/(1.0 + IDiff_f*IDiff_f/9.0);

					Tempu_f[CLoc] = u_f[CLoc] + (
									  Front_f*(	u_f[FLoc] - u_f[CLoc]) +
									  Back_f*(	u_f[BLoc] - u_f[CLoc]) +
									  Left_f*(	u_f[LLoc] - u_f[CLoc]) +
									  Right_f*(	u_f[RLoc] - u_f[CLoc]) + 
									  Up_f*(	u_f[ULoc] - u_f[CLoc]) + 
									  Down_f*(	u_f[DLoc] - u_f[CLoc]))/6.0;
				}
			}
		}
    

		for (i=0; i<WHD_mi; i++) u_f[i] = Tempu_f[i];
    
	}
 

	for (i=0; i<WHD_mi; i++) ScalarValues[i] = (T)u_f[i];

	delete [] u_f;
	delete [] Tempu_f;
}



template<class T>
void GaussianSmoothing3D(T *data, int WindowSize)
{
	int		i, j, k, loc[3], l, m, n, Xi, Yi, Zi;
	int		WtimesH = inWidth_gi*inHeight_gi;
	int		WHD = inWidth_gi*inHeight_gi*inDepth_gi;
	int		WW = WindowSize*WindowSize;
	double	*Kernel3D, GaussianSum_d;
	
	
	T	*TempData = new T [WHD];
	for (i=0; i<WHD; i++) TempData[i] = data[i];
	
	switch (WindowSize) {
		case 3: Kernel3D = &GaussianKernel_3x3x3_d[0][0][0]; break;
		case 5: Kernel3D = &GaussianKernel_5x5x5_d[0][0][0]; break;
		case 7: Kernel3D = &GaussianKernel_7x7x7_d[0][0][0]; break;
		case 9: Kernel3D = &GaussianKernel_9x9x9_d[0][0][0]; break;
		case 11: Kernel3D = &GaussianKernel_11x11x11_d[0][0][0]; break;
		default: 
			printf ("There is no %d window size kernel, ", WindowSize);
			printf ("Default size is 3\n"); fflush (stdout);
			Kernel3D = &GaussianKernel_3x3x3_d[0][0][0]; 
			break;
	}
	
	int		PInterval = 1000000;
	for (loc[0]=0; loc[0]<WHD; loc[0]++) {

		if (loc[0]%PInterval==0) {
			printf ("Gaussian Smoothing3D: Progress = %d/%d, ", loc[0]/PInterval, WHD/PInterval);
			printf ("\n"); fflush (stdout);
		}

		Zi = loc[0]/WtimesH;
		Yi = (loc[0] - Zi*WtimesH)/inWidth_gi;
		Xi = loc[0] % inWidth_gi;

		GaussianSum_d = 0.0;
		for (n=0, k=Zi-WindowSize/2; k<=Zi+WindowSize/2; k++, n++) {
			for (m=0, j=Yi-WindowSize/2; j<=Yi+WindowSize/2; j++, m++) {
				for (l=0, i=Xi-WindowSize/2; i<=Xi+WindowSize/2; i++, l++) {
					loc[1] = Index (i, j, k);
					GaussianSum_d += (double)TempData[loc[1]]*Kernel3D[n*WW + m*WindowSize + l];
				}
			}
		}
		data[loc[0]] = (T)(GaussianSum_d);

	}
	delete [] TempData;

}


template<class T>
T *Bilateral_Filter(T *data, int WindowSize, double& Min, double& Max, double S1, double S2)
{
	int     i, xj, yj, zj, l, m, n, WHD, WtimesH, loc[3];
	double	Sigma_Domain, Sigma_Range;
	double	*Domain_Filter, Range_Filter, Bilateral_Filter, f_abc;
	double	Sum_Bilateral, Sum_Weighted_Data;
	T		*New_Data;

	if (WindowSize==0) return NULL;
	
	Sigma_Domain = S1;
	Sigma_Range = S2;
	WtimesH = inWidth_gi*inHeight_gi;
	WHD = inWidth_gi*inHeight_gi*inDepth_gi;
	
	New_Data = new T [WHD];
	Domain_Filter = new double [WindowSize*WindowSize*WindowSize];

	if (inDepth_gi==1) {

		for (l=-WindowSize/2; l<=WindowSize/2; l++) {
			for (m=-WindowSize/2; m<=WindowSize/2; m++) {
				loc[0] = (l+WindowSize/2)*WindowSize + (m+WindowSize/2);
				Domain_Filter[loc[0]] = exp(-(l*l + m*m)/Sigma_Domain); // <-- Traditional
			}
		}
		for (yj=0; yj<inHeight_gi; yj++) {
			for (xj=0; xj<inWidth_gi; xj++) {

				Sum_Bilateral=0.0;
				Sum_Weighted_Data=0.0;
				loc[2] = yj*inWidth_gi + xj;
				for (l=-WindowSize/2+yj; l<=WindowSize/2+yj; l++) {
					for (m=-WindowSize/2+xj; m<=WindowSize/2+xj; m++) {
						loc[0] = l*inWidth_gi + m;
						loc[1] = (l+WindowSize/2-yj)*WindowSize + (m+WindowSize/2-xj);

						if (l<0 || m<0 || l>=inHeight_gi || m>=inWidth_gi) f_abc = 0.0;
						else f_abc = data[loc[0]];
						//Range_Filter = exp(-(f_abc-data[loc[2]])*(f_abc-data[loc[2]])/Sigma_Range);
						Range_Filter = (double)1.0/(1.0 + (f_abc-data[loc[2]])*(f_abc-data[loc[2]])/Sigma_Range);
						Bilateral_Filter = Range_Filter*Domain_Filter[loc[1]];

						Sum_Weighted_Data += Bilateral_Filter * f_abc;
						Sum_Bilateral += Bilateral_Filter;
					}
				}
				loc[0] = yj*inWidth_gi + xj;
				New_Data[loc[0]] = (T)(Sum_Weighted_Data/Sum_Bilateral);
			}
		}
	}
	else {

		for (n=-WindowSize/2; n<=WindowSize/2; n++)  {
			for (l=-WindowSize/2; l<=WindowSize/2; l++) {
				for (m=-WindowSize/2; m<=WindowSize/2; m++) {
					loc[0] = (n+WindowSize/2)*WindowSize*WindowSize + (l+WindowSize/2)*WindowSize + (m+WindowSize/2);
					Domain_Filter[loc[0]] = exp(-(n*n + l*l + m*m)/Sigma_Domain); // <-- Traditional
				}
			}
		}
		for (zj=0; zj<inDepth_gi; zj++) {
			for (yj=0; yj<inHeight_gi; yj++) {
				for (xj=0; xj<inWidth_gi; xj++) {

					Sum_Bilateral=0.0;
					Sum_Weighted_Data=0.0;
					loc[2] = zj*WtimesH + yj*inWidth_gi + xj;
					for (n=-WindowSize/2+zj; n<=WindowSize/2+zj; n++)  {
						for (l=-WindowSize/2+yj; l<=WindowSize/2+yj; l++) {
							for (m=-WindowSize/2+xj; m<=WindowSize/2+xj; m++) {
							
								loc[0] = n*WtimesH + l*inWidth_gi + m;
								loc[1] = (n+WindowSize/2-zj)*WindowSize*WindowSize + 
											(l+WindowSize/2-yj)*WindowSize + (m+WindowSize/2-xj);
								if (n<0 || l<0 || m<0 || n>=inDepth_gi || l>=inHeight_gi || m>=inWidth_gi) f_abc = 0.0;
								else f_abc = data[loc[0]];
								Range_Filter = exp(-(f_abc-data[loc[2]])*(f_abc-data[loc[2]])/Sigma_Range); // <-- Traditional
								Bilateral_Filter = Range_Filter*Domain_Filter[loc[1]];
								
								Sum_Weighted_Data += Bilateral_Filter * f_abc;
								Sum_Bilateral += Bilateral_Filter;
							}
						}
					}
					loc[0] = zj*WtimesH + yj*inWidth_gi + xj;
					New_Data[loc[0]] = (T)(Sum_Weighted_Data/Sum_Bilateral);

				}
			}
		}
	}
	
	Min = DBL_MAX;
	Max = -DBL_MAX;
	for (i=0; i<WHD; i++) {
		if ((double)New_Data[i]<Min) Min = (double)New_Data[i];
		if ((double)New_Data[i]>Max) Max = (double)New_Data[i];
	}
	
	delete [] Domain_Filter;
	
	return New_Data;
}


template<class T>
float *Mean_Filter(T *data, int WindowSize, double& Min, double& Max)
{
	int     i, xj, yj, zj, l, m, n, WHD, WtimesH, loc[3], NumAddedVoxels;
	double	Sum_Weighted_Data;
	T		*New_Data;


	WtimesH = inWidth_gi*inHeight_gi;
	WHD = inWidth_gi*inHeight_gi*inDepth_gi;
	
	New_Data = new T [WHD];

	if (inDepth_gi==1) {

		for (yj=0; yj<inHeight_gi; yj++) {
			for (xj=0; xj<inWidth_gi; xj++) {

				loc[2] = yj*inWidth_gi + xj;
				Sum_Weighted_Data = 0.0;
				NumAddedVoxels = 0;
				for (l=-WindowSize/2+yj; l<=WindowSize/2+yj; l++) {
					for (m=-WindowSize/2+xj; m<=WindowSize/2+xj; m++) {

						if (l<0 || m<0 || l>=inHeight_gi || m>=inWidth_gi) { }
						else {
							loc[0] = l*inWidth_gi + m;
							Sum_Weighted_Data += (double)data[loc[0]];
							NumAddedVoxels++;
						}
					}
				}
				Sum_Weighted_Data /= NumAddedVoxels;
				New_Data[loc[2]] = (T)Sum_Weighted_Data;
			}
		}
	}
	else { // 3D Case
/*
		for (n=-WindowSize/2; n<=WindowSize/2; n++)  {
			for (l=-WindowSize/2; l<=WindowSize/2; l++) {
				for (m=-WindowSize/2; m<=WindowSize/2; m++) {
					loc[0] = (n+WindowSize/2)*WindowSize*WindowSize + (l+WindowSize/2)*WindowSize + (m+WindowSize/2);
					Domain_Filter[loc[0]] = exp(-(n*n + l*l + m*m)/Sigma_Domain);
				}
			}
		}
		for (zj=0; zj<inDepth_gi; zj++) {
			for (yj=0; yj<inHeight_gi; yj++) {
				for (xj=0; xj<inWidth_gi; xj++) {

					Sum_Bilateral=0.0;
					Sum_Weighted_Data=0.0;
					loc[2] = zj*WtimesH + yj*inWidth_gi + xj;
					for (n=-WindowSize/2+zj; n<=WindowSize/2+zj; n++)  {
						for (l=-WindowSize/2+yj; l<=WindowSize/2+yj; l++) {
							for (m=-WindowSize/2+xj; m<=WindowSize/2+xj; m++) {
							
								loc[0] = n*WtimesH + l*inWidth_gi + m;
								loc[1] = (n+WindowSize/2-zj)*WindowSize*WindowSize + 
											(l+WindowSize/2-yj)*WindowSize + (m+WindowSize/2-xj);
								if (n<0 || l<0 || m<0 || n>=inDepth_gi || l>=inHeight_gi || m>=inWidth_gi) f_abc = 0.0;
								else f_abc = data[loc[0]];
								Range_Filter = exp(-(f_abc-data[loc[2]])*(f_abc-data[loc[2]])/Sigma_Range);
								Bilateral_Filter = Range_Filter*Domain_Filter[loc[1]];
								
								Sum_Weighted_Data += Bilateral_Filter * f_abc;
								Sum_Bilateral += Bilateral_Filter;
							}
						}
					}
					loc[0] = zj*WtimesH + yj*inWidth_gi + xj;
					New_Data[loc[0]] = Sum_Weighted_Data/Sum_Bilateral;

				}
			}
		}
*/
	}

	Min = DBL_MAX;
	Max = -DBL_MAX;
	for (i=0; i<WHD; i++) {
		if ((double)New_Data[i]<Min) Min = (double)New_Data[i];
		if ((double)New_Data[i]>Max) Max = (double)New_Data[i];
	}
	
	return New_Data;
}



template<class T>
void SaveVolume(T *data, float Minf, float Maxf, char *Name)
{
	char	OutFileName[200];
	int     binfile_fd2;
	int		WHD;


	printf ("Minf = %f Maxf = %f\n", Minf, Maxf);
	
	if (Name==NULL) return;
	WHD = inWidth_gi*inHeight_gi*inDepth_gi;
	

	if (RawivHeader_guc!=NULL) {
		sprintf (OutFileName, "%s_%s.rawiv", TargetName_gc, Name);
	}
	else {
		sprintf (OutFileName, "%s_%s.raw", TargetName_gc, Name);
	}
	printf ("Output File = %s\n", OutFileName);
	printf ("Size of each elements = %d\n", (int)sizeof(data[0]));
	printf ("\n"); fflush(stdout);

	if ((binfile_fd2 = open (OutFileName, O_CREAT | O_WRONLY | O_TRUNC)) < 0) {
		printf ("could not open %s\n", OutFileName);
		exit(1);
	}
	if (RawivHeader_guc!=NULL) {
		if (write(binfile_fd2, RawivHeader_guc, 68)	!= 68) {
			printf ("SaveV1: The file could not be written : %s\n", OutFileName);
			close (binfile_fd2);
			exit(1);
		}
	}
	if (write(binfile_fd2, data, sizeof(T)*WHD)	!=(unsigned int)sizeof(T)*WHD) {
		printf ("SaveV2: The file could not be written : %s\n", OutFileName);
		close (binfile_fd2);
		exit(1);
	}
	close (binfile_fd2);
	if (chmod(OutFileName, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH) < 0) {
		printf ("chmod was not worked to file %s\n", OutFileName);
		exit(1);
	}


}



template<class T>
void SaveVolumeRawivFormat(T *data, float Minf, float Maxf, char *Name, int ResX, int ResY, int ResZ,
				float SpanX, float SpanY, float SpanZ)
{

	SaveVolumeRawivFormat(data, Minf, Maxf, Name, ResX, ResY, ResZ, SpanX, SpanY, SpanZ, false);
}

template<class T>
void SaveVolumeRawivFormat(T *data, float Minf, float Maxf, char *Name, int ResX, int ResY, int ResZ,
				float SpanX, float SpanY, float SpanZ, int FlipX)
{
	char	OutFileName[200];
	int     binfile_fd2;
	int		i, j, k, WHD, loc[3];
	float	MinCoor_f[3];	// The coordinates of the 1st voxel.
	float	MaxCoor_f[3];	// The coordinates of the last voxel.
	int		NumVerts_i;	// The number of vertices in the grid = DimX * DimY * DimZ
	int		NumCells_i;	// The number of Cells in the grid = (DimX-1) * (DimY-1) * (DimZ-1)
	int		DimX_i, DimY_i, DimZ_i;	// The number of vertices in each direction
	float 	OriginX_f, OriginY_f, OriginZ_f;	// = the coordinates of the 1st voxel
	float	SpanX_f, SpanY_f, SpanZ_f;	// SpanX = (MaxCoor_gf[0]-MinCoor_gf[0])/(DimX-1)


	printf ("Minf = %f Maxf = %f\n", Minf, Maxf);

	if (Name==NULL) return;
	WHD = ResX*ResY*ResZ;
	

	if (RawivHeader_guc!=NULL) {
		sprintf (OutFileName, "%s_%s.rawiv", TargetName_gc, Name);
	}
	else {
		sprintf (OutFileName, "%s_%s.raw", TargetName_gc, Name);
	}
	printf ("Output File = %s\n", OutFileName);
	printf ("Size of each elements = %d\n", (int)sizeof(data[0]));
	printf ("\n"); fflush(stdout);

	if ((binfile_fd2 = open (OutFileName, O_CREAT | O_WRONLY | O_TRUNC)) < 0) {
		printf ("Could not open %s\n", OutFileName);
		exit(1);
	}
	
	SpanX_f = SpanX;
	SpanY_f = SpanY;
	SpanZ_f = SpanZ;
	MinCoor_f[0] = MinCoor_f[1] = MinCoor_f[2] = 0.0;
	MaxCoor_f[0] = SpanX_f*(ResX-1) + MinCoor_f[0];
	MaxCoor_f[1] = SpanY_f*(ResY-1) + MinCoor_f[1];
	MaxCoor_f[2] = SpanZ_f*(ResZ-1) + MinCoor_f[2];
	NumVerts_i = ResX*ResY*ResZ;
	NumCells_i = (ResX-1)*(ResY-1)*(ResZ-1);
	DimX_i = ResX; 
	DimY_i = ResY; 
	DimZ_i = ResZ;
	OriginX_f = OriginY_f = OriginZ_f = 0.0;

	printf ("Min = (%f, %f, %f)\n", MinCoor_f[0], MinCoor_f[1], MinCoor_f[2]);
	printf ("Max = (%f, %f, %f)\n", MaxCoor_f[0], MaxCoor_f[1], MaxCoor_f[2]);
	printf ("NumVerts = %d, NumCells = %d\n", NumVerts_i, NumCells_i);
	printf ("DimX, DimY, DimZ = %d %d %d\n", DimX_i, DimY_i, DimZ_i);
	printf ("OriginX, OriginY, OriginZ = %f %f %f\n", OriginX_f, OriginY_f, OriginZ_f);
	printf ("SpanX, SpanY, SpanZ = %f %f %f\n", SpanX_f, SpanY_f, SpanZ_f);
	printf ("\n"); fflush (stdout);

	if (FlipX==true) {
		T *data_TempX = new T [ResX];
		for (k=0; k<ResZ; k++) {
			for (j=0; j<ResY; j++) {
				for (i=0; i<ResX; i++) {
					loc[0] = k*ResX*ResY + j*ResX + i;
					data_TempX[i] = data[loc[0]];
				}
				for (i=0; i<ResX; i++) {
					loc[0] = k*ResX*ResY + j*ResX + i;
					data[loc[0]] = data_TempX[ResX-i-1];
				}
			}
		}
		delete [] data_TempX;
	}


	if (DoSwapByteOrder_gc!=NULL & (strcmp(DoSwapByteOrder_gc, "Yes")==0 || 
		strcmp(DoSwapByteOrder_gc, "yes")==0 || strcmp(DoSwapByteOrder_gc, "YES")==0)) {
		SwapByteOrder(&MinCoor_f[0]);  SwapByteOrder(&MinCoor_f[1]);  SwapByteOrder(&MinCoor_f[2]);
		SwapByteOrder(&MaxCoor_f[0]);  SwapByteOrder(&MaxCoor_f[1]);  SwapByteOrder(&MaxCoor_f[2]);
		SwapByteOrder(&NumVerts_i);
		SwapByteOrder(&NumCells_i);
		SwapByteOrder(&DimX_i);	SwapByteOrder(&DimY_i);	SwapByteOrder(&DimZ_i);
		SwapByteOrder(&OriginX_f);	SwapByteOrder(&OriginY_f);	SwapByteOrder(&OriginZ_f);
		SwapByteOrder(&SpanX_f);	SwapByteOrder(&SpanY_f);	SwapByteOrder(&SpanZ_f);
		if (sizeof(data[0])==1) { }
		else {
			for (int i=0; i<WHD; i++) SwapByteOrder(&data[i]);
		}
	}
	
	write(binfile_fd2, MinCoor_f, sizeof(float)*3); // 4 bytes * 3 = 12 bytes
	write(binfile_fd2, MaxCoor_f, sizeof(float)*3); // 4 bytes * 3 = 12 bytes

	write(binfile_fd2, &NumVerts_i, sizeof(int)); // 4 bytes 
	write(binfile_fd2, &NumCells_i, sizeof(int)); // 4 bytes 

	write(binfile_fd2, &DimX_i, sizeof(int)); // 4 bytes
	write(binfile_fd2, &DimY_i, sizeof(int)); // 4 bytes
	write(binfile_fd2, &DimZ_i, sizeof(int)); // 4 bytes

	write(binfile_fd2, &OriginX_f, sizeof(float)); // 4 bytes
	write(binfile_fd2, &OriginY_f, sizeof(float)); // 4 bytes
	write(binfile_fd2, &OriginZ_f, sizeof(float)); // 4 bytes

	write(binfile_fd2, &SpanX_f, sizeof(float)); // 4 bytes 56th
	write(binfile_fd2, &SpanY_f, sizeof(float)); // 4 bytes
	write(binfile_fd2, &SpanZ_f, sizeof(float)); // 4 bytes


	if (write(binfile_fd2, data, sizeof(T)*WHD)	!=(unsigned int)sizeof(T)*WHD) {
		printf ("SaveV2: The file could not be written : %s\n", OutFileName);
		close (binfile_fd2);
		exit(1);
	}

	
	close (binfile_fd2);
	if (chmod(OutFileName, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH) < 0) {
		printf ("chmod was not worked to file %s\n", OutFileName);
		exit(1);
	}

	if (FlipX==true) {
		T *data_TempX = new T [ResX];
		for (k=0; k<ResZ; k++) {
			for (j=0; j<ResY; j++) {
				for (i=0; i<ResX; i++) {
					loc[0] = k*ResX*ResY + j*ResX + i;
					data_TempX[i] = data[loc[0]];
				}
				for (i=0; i<ResX; i++) {
					loc[0] = k*ResX*ResY + j*ResX + i;
					data[loc[0]] = data_TempX[ResX-i-1];
				}
			}
		}
		delete [] data_TempX;
	}


}







//------------------------------------------------------------------------------------

void SwapByteOrder(unsigned char *data)
{ unsigned char *Tempuc = data; data = Tempuc; }

void SwapByteOrder(char *data)
{  char *Tempc = data; data = Tempc; }

void SwapByteOrder(unsigned short *data)
{
	unsigned short	Temp1, Temp2;
	
	Temp1 = *data << 8;
	Temp2 = *data >> 8;
	*data = Temp1 | Temp2;
}

void SwapByteOrder(short *data)
{
	unsigned short	Temp1, Temp2;
	
	Temp1 = *data << 8;
	Temp2 = *data >> 8;
	*data = Temp1 | Temp2;
}

void SwapByteOrder(float *data)
{
	unsigned char	*T1c, *T2c, *T3c, *T4c, Tc;
	
	T1c = (unsigned char *)data;
	T2c = &T1c[1];
	T3c = &T1c[2];
	T4c = &T1c[3];
	
	Tc = *T1c;
	*T1c = *T4c;
	*T4c = Tc;
		
	Tc = *T2c;
	*T2c = *T3c;
	*T3c = Tc;
}

void SwapByteOrder(unsigned int *data)
{
	unsigned char	*T1c, *T2c, *T3c, *T4c, Tc;
	
	T1c = (unsigned char *)data;
	T2c = &T1c[1];
	T3c = &T1c[2];
	T4c = &T1c[3];
	
	Tc = *T1c;
	*T1c = *T4c;
	*T4c = Tc;
		
	Tc = *T2c;
	*T2c = *T3c;
	*T3c = Tc;
}

void SwapByteOrder(int *data)
{
	unsigned char	*T1c, *T2c, *T3c, *T4c, Tc;
	
	T1c = (unsigned char *)data;
	T2c = &T1c[1];
	T3c = &T1c[2];
	T4c = &T1c[3];
	
	Tc = *T1c;
	*T1c = *T4c;
	*T4c = Tc;
		
	Tc = *T2c;
	*T2c = *T3c;
	*T3c = Tc;
}


// Uniform Radom Number Generator from 0 to 1
double RandomNum()
{
	double	UniformRandomNum;

	UniformRandomNum = (double)rand();
	UniformRandomNum /= (double)RAND_MAX;
	return (double)UniformRandomNum; // from 0 to 1
}

double RandomNum(unsigned int Seed)
{
	double	UniformRandomNum;

	srand(Seed);
	UniformRandomNum = (double)rand();
	UniformRandomNum /= (double)RAND_MAX;
	return (double)UniformRandomNum; // from 0 to 1
}

// Uniform Radom Number Generator from Minf to Maxf
float RandomNum(float Minf, float Maxf)
{
	double	UniformRandomNum;

	UniformRandomNum = (double)rand();
	UniformRandomNum /= (double)RAND_MAX;
	UniformRandomNum *= (Maxf - Minf);
	UniformRandomNum += Minf;
	
	return (float)UniformRandomNum; // from 0 to 1
}

// Uniform Radom Number Generator from Minf to Maxf
double RandomNum(double Mind, double Maxd)
{
	double	UniformRandomNum;

	UniformRandomNum = (double)rand();
	UniformRandomNum /= (double)RAND_MAX;
	UniformRandomNum *= (Maxd - Mind);
	UniformRandomNum += Mind;
	
	return (double)UniformRandomNum;
}

// Save a RGB Image
void SaveImage(int Width, int Height, unsigned char *Image, char *PPMFile)
{
	ofstream image_file(PPMFile);

	int img_len = Width*Height;
	printf ("File Name = %s, ", PPMFile);
	printf("image size : %d %d\n", Width, Height); fflush (stdout);
	image_file << "P3\n" << Width << " " << Height << "\n255\n";
	for (int i=0; i<img_len; i++) {
		image_file << (int)Image[i*3+0] << " " << (int)Image[i*3+1] << " " << (int)Image[i*3+2];
		image_file << endl;
	}

	image_file.close();
   
}


/*
Bresenham's algorithm for ellipses

void symmetry( int x, int y )
{
    PUT_PIXEL ( -x, -y );  PUT_PIXEL ( +x, -y );
    PUT_PIXEL ( -x, +y );  PUT_PIXEL ( +x, +y );
}

void bresenham_ellipse( int a, int b )
{
    int x,y,a2,b2, S, T;
    
    a2 = a*a;
    b2 = b*b;
    x = 0;
    y = b;
    S = a2*(1-2*b) + 2*b2;
    T = b2 - 2*a2*(2*b-1);
    symmetry(x,y);
    do {
        if (S<0) {
            S += 2*b2*(2*x+3);
            T += 4*b2*(x+1);
            x++;
        } else if (T<0) {
            S += 2*b2*(2*x+3) - 4*a2*(y-1);
            T += 4*b2*(x+1) - 2*a2*(2*y-3);
            x++;
            y--;
        } else {
            S -= 4*a2*(y-1);
            T -= 2*a2*(2*y-3);
            y--;
        }
        symmetry(x,y);
    } while (y>0);
}

See also gdImageEllipse() function in file "bresenham_ellipse"
of the libgd 2.0.1 package
   http://www.boutell.com/gd/manual2.0.html

-------------------------------------------------------------------------------
//
// CONIC  2D Bresenham-like conic drawer.
//   CONIC(Sx,Sy, Ex,Ey, A,B,C,D,E,F) draws the conic specified
//   by A x^2 + B x y + C y^2 + D x + E y + F = 0, between the
//   start point (Sx, Sy) and endpoint (Ex,Ey).

// Author: Andrew W. Fitzgibbon (andrewfg@ed.ac.uk),
//     Machine Vision Unit,
//         Dept. of Artificial Intelligence,
//     Edinburgh University, 5 Forrest Hill, EH1 2QL, UK
//     
// Date: 31-Mar-94

#include <stdlib.h>
#include <stdio.h>
#include <math.h>

static int DIAGx[] = {999, 1,  1, -1, -1, -1, -1,  1,  1};
static int DIAGy[] = {999, 1,  1,  1,  1, -1, -1, -1, -1};
static int SIDEx[] = {999, 1,  0,  0, -1, -1,  0,  0,  1};
static int SIDEy[] = {999, 0,  1,  1,  0,  0, -1, -1,  0};
static int BSIGNS[] = {99, 1,  1, -1, -1,  1,  1, -1, -1};

int   debugging = 1;

struct ConicPlotter {
  virtual void plot(int x, int y);
};

struct DebugPlotter : public ConicPlotter {
  int xs;
  int ys;
  int xe;
  int ye;
  int A;
  int B;
  int C;
  int D;
  int E;
  int F;      

  int octant;
  int d;

  void plot(int x, int y);
};

void DebugPlotter::plot(int x, int y)
{
  printf("%3d %3d\n",x,y);

  if (debugging) {
    // Translate start point to origin...
    float tF = A*xs*xs + B*xs*ys + C*ys*ys + D*xs + E*ys + F;
    float tD = D + 2 * A * xs + B * ys;
    float tE = E + B * xs + 2 * C * ys;
  
    float tx = x - xs + ((float)DIAGx[octant] + SIDEx[octant])/2;
    float ty = y - ys + ((float)DIAGy[octant] + SIDEy[octant])/2;
    // Calculate F
    
    float td = 4*(A*tx*tx + B*tx*ty + C*ty*ty + tD*tx + tE*ty + tF);
    
    fprintf(stderr,"O%d ", octant);
    if (d<0)
      fprintf(stderr," Inside "); 
    else 
      fprintf(stderr,"Outside "); 
    float err = td - d;
    fprintf(stderr,"Real(%5.1f,%5.1f) = %8.2f Recurred = %8.2f err = %g\n", 
        tx, ty, td/4, d/4.0f, err);
    if (fabs(err) > 1e-14)
      abort();
  }
  
}

inline int odd(int n)
{
  return n&1;
}

inline int abs(int a)
{
  if (a > 0)
    return a;
  else
    return -a;
}
    
int getoctant(int gx, int gy)
{
  // Use gradient to identify octant.
  int upper = abs(gx)>abs(gy);
  if (gx>=0)                // Right-pointing
    if (gy>=0)              //    Up
      return 4 - upper;
    else                //    Down
      return 1 + upper;
  else                  // Left
    if (gy>0)               //    Up
      return 5 + upper;
    else                //    Down
      return 8 - upper;
}

int conic(int xs, int ys, int xe, int ye,
      int A, int B, int C, int D, int E, int F,
      ConicPlotter * plotterdata)
{
  A *= 4;
  B *= 4;
  C *= 4;
  D *= 4;
  E *= 4;
  F *= 4;
  
  // Translate start point to origin...
  F = A*xs*xs + B*xs*ys + C*ys*ys + D*xs + E*ys + F;
  D = D + 2 * A * xs + B * ys;
  E = E + B * xs + 2 * C * ys;
  
  // Work out starting octant
  int octant = getoctant(D,E);
  
  int dxS = SIDEx[octant]; 
  int dyS = SIDEy[octant]; 
  int dxD = DIAGx[octant];
  int dyD = DIAGy[octant];

  int bsign = BSIGNS[octant];
  int d,u,v;
  switch (octant) {
  case 1:
    d = A + B/2 + C/4 + D + E/2 + F;
    u = A + B/2 + D;
    v = u + E;
    break;
  case 2:
    d = A/4 + B/2 + C + D/2 + E + F;
    u = B/2 + C + E;
    v = u + D;
    break;
  case 3:
    d = A/4 - B/2 + C - D/2 + E + F;
    u = -B/2 + C + E;
    v = u - D;
    break;
  case 4:
    d = A - B/2 + C/4 - D + E/2 + F;
    u = A - B/2 - D;
    v = u + E;
    break;
  case 5:
    d = A + B/2 + C/4 - D - E/2 + F;
    u = A + B/2 - D;
    v = u - E;
    break;
  case 6:
    d = A/4 + B/2 + C - D/2 - E + F;
    u = B/2 + C - E;
    v = u - D;
    break;
  case 7:
    d = A/4 - B/2 + C + D/2 - E + F;
    u =  -B/2 + C - E;
    v = u + D;
    break;
  case 8:
    d = A - B/2 + C/4 + D - E/2 + F;
    u = A - B/2 + D;
    v = u - E;
    break;
  default:
    fprintf(stderr,"FUNNY OCTANT\n");
    abort();
  }
  
  int k1sign = dyS*dyD;
  int k1 = 2 * (A + k1sign * (C - A));
  int Bsign = dxD*dyD;
  int k2 = k1 + Bsign * B;
  int k3 = 2 * (A + C + Bsign * B);

  // Work out gradient at endpoint
  int gxe = xe - xs;
  int gye = ye - ys;
  int gx = 2*A*gxe +   B*gye + D;
  int gy =   B*gxe + 2*C*gye + E;
  
  int octantcount = getoctant(gx,gy) - octant;
  if (octantcount <= 0)
    octantcount = octantcount + 8;
  fprintf(stderr,"octantcount = %d\n", octantcount);
  
  int x = xs;
  int y = ys;
  
  while (octantcount > 0) {
    if (debugging)
      fprintf(stderr,"-- %d -------------------------\n", octant); 
    
    if (odd(octant)) {
      while (2*v <= k2) {
    // Plot this point
    ((DebugPlotter*)plotterdata)->octant = octant;
    ((DebugPlotter*)plotterdata)->d = d;
    plotterdata->plot(x,y);
    
    // Are we inside or outside?
    if (d < 0) {            // Inside
      x = x + dxS;
      y = y + dyS;
      u = u + k1;
      v = v + k2;
      d = d + u;
    }
    else {              // outside
      x = x + dxD;
      y = y + dyD;
      u = u + k2;
      v = v + k3;
      d = d + v;
    }
      }
    
      d = d - u + v/2 - k2/2 + 3*k3/8; 
      // error (^) in Foley and van Dam p 959, "2nd ed, revised 5th printing"
      u = -u + v - k2/2 + k3/2;
      v = v - k2 + k3/2;
      k1 = k1 - 2*k2 + k3;
      k2 = k3 - k2;
      int tmp = dxS; dxS = -dyS; dyS = tmp;
    }
    else {              // Octant is even
      while (2*u < k2) {
    // Plot this point
    ((DebugPlotter*)plotterdata)->octant = octant;
    ((DebugPlotter*)plotterdata)->d = d;
    plotterdata->plot(x,y);
    
    // Are we inside or outside?
    if (d > 0) {            // Outside
      x = x + dxS;
      y = y + dyS;
      u = u + k1;
      v = v + k2;
      d = d + u;
    }
    else {              // Inside
      x = x + dxD;
nt tmpdk = k1 - k2;
      d = d + u - v + tmpdk;
      v = 2*u - v + tmpdk;
      u = u + tmpdk;
      k3 = k3 + 4*tmpdk;
      k2 = k1 + tmpdk;
      
      int tmp = dxD; dxD = -dyD; dyD = tmp;
    }
    
    octant = (octant&7)+1;
    octantcount--;
  }

  // Draw final octant until we reach the endpoint
  if (debugging)
    fprintf(stderr,"-- %d (final) -----------------\n", octant); 
    
  if (odd(octant)) {
    while (2*v <= k2 && x != xe && y != ye) {
      // Plot this point
      ((DebugPlotter*)plotterdata)->octant = octant;
      ((DebugPlotter*)plotterdata)->d = d;
      plotterdata->plot(x,y);
      
      // Are we inside or outside?
      if (d < 0) {          // Inside
    x = x + dxS;
    y = y + dyS;
    u = u + k1;
    v = v + k2;
    d = d + u;
      }
      else {                // outside
    x = x + dxD;
    y = y + dyD;
    u = u + k2;
    v = v + k3;
    d = d + v;
      }
    }
  }
  else {                // Octant is even
    while ((2*u < k2) && (x != xe) && (y != ye)) {
      // Plot this point
      ((DebugPlotter*)plotterdata)->octant = octant;
      ((DebugPlotter*)plotterdata)->d = d;
      plotterdata->plot(x,y);
      
      // Are we inside or outside?
      if (d > 0) {          // Outside
    x = x + dxS;
    y = y + dyS;
    u = u + k1;
    v = v + k2;
    d = d + u;
      }
      else {                // Inside
    x = x + dxD;
    y = y + dyD;
    u = u + k2;
    v = v + k3;
    d = d + v;
      }
    }
  }



  return 1;
}

main(int argc, char ** argv)
{
  DebugPlotter db;
  db.xs = -7;
  db.ys = -19;
  db.xe = -8;
  db.ye = -8;
  db.A = 1424;
  db.B = -964;
  db.C = 276;
  db.D = 0;
  db.E = 0;
  db.F = -40000;
  conic(db.xs,db.ys,db.xe,db.ye,db.A,db.B,db.C,db.D,db.E,db.F, &db);
}

*/

